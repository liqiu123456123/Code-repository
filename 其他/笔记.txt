面试官好，我叫李齐乐，20年通信工程专业毕业。目前为止有3段工作经历，工作的岗位都不太一样，但是都和python有些联系。刚毕业的时候我是在新疆，岗位是数据分析师，
这个时期我还是一个脚本小子，主要使用Python写一些处理数据的脚本。放到本地或者服务器上跑一跑。后来来到深圳富士康，这个时候比原来好了一些，开始独立使用python开发一些数据处理和可视化的工具，
一般还会带有GUI界面。最近一份工作是在易宝软件，做的是荣耀的外包项目。我主要负责图像采集和清洗以及标注工具的开发。涉及到QT和一些基础的图像算法。这个时期自己会开始做一些框架项目和阅读一些进阶的python书籍，
像《流畅的Python》和《健壮的Python》等。我之前的经历都不是典型的开发岗位，处理过的需求比较零散加上距离的时间比较长。所以我简历上放了3个我个人近期做的项目，并且源码都放在了GitHub上。
自动化数据清洗的项目和处理证件照的项目和我在富士康和易宝的工作内容很像，使用的技术和处理的需求基本一致。基本上可以概括我在这两家公司的工作内容。工作闲暇之余，我会活跃在各个技术社群与论坛进行交流和学习，
目前个人博客总结与分享有400多篇。总浏览量超过40W。我觉得这个岗位和我还是比较匹配的，希望能得到这个工作机会。以上就是我的自我介绍。


Automated_data_cleaning
情景：因为我前两份工作经常需要处理数据，然后我就想，像是数据清洗工作，如果数据量比较大的话，Excel是无法满足需求的。但是使用python进行数据清洗对没接触过编程的人来说有一定门槛。
我就想设计这样一个工具，可以像Excel一样进行界面化的操作，也可以处理比较大的数据量。为了方便跨设备处理数据，我增加了一个云盘的功能。在项目使用技术上，前端使用QT进行GUI的开发，
Pandas支撑数据清洗功能的完成，Django提供云盘服务。前端和后端的交互通过request库发请求的方式实现。目前基本完成了常用数据清洗功能的完成，
并且对清洗功能做了串联，提前各个选项的菜单设置好，一键运行即可。
然后我介绍1个我觉得还不错的亮点：
1.它可以接近于实时显示大excel文件数据和显示读取Excel文件的进度。据我了解到的，目前主流的python处理excel文件的库是没有办法直接做到这一点的。
要读取文件到显示在数据区域，需要经过3个步骤。1是读取文件，
2是把读取的文件用合适的数据结构存到python对象中，3是写入到qt的数据显示控件。这3个步骤每一步都会花比较长的时间
针对这3个步骤，我是这样优化的，读取文件我不是直接读取，我用了一个生成器对象来接收这个文件。再把生成器传入到qt显示控件中的同时，开启一个线程，
在后台对这个生成器进行遍历，把数据存到列表中，在这个生成器遍历保存数据到python对象的过程中，我会输出一个进度，用这个进度来近似代替读取Excel文件的进度。在写入QT数据显示数据的这个环节，
我采用了分页显示的的方法，每次只显示一页。这样可以极大优化数据写入QT控件的的速度。近于实时显示。


WeTalk
情境：现在app很臃肿，会往里面塞很多多余的功能，而且会获取很多个人信息。
我的初衷是开发一款单纯只用来进行交流的网页应用，抛弃了app的形式，免安装使用，同时使用人脸识别的方式进行注册和登录，不需要账号和密码，随用随登，让用户专注于功能本身，
最大限度降低使用成本。
行动+结果：如果需要做实时通讯的话，传统的http协议是不太理想的，它很被动，只能是客户端发起请求，然后服务器返回结果，没有办法做一个双向的互动。
这里用到一个WebSocket协议，WebSocket是一个双向通信协议，最大的特点就是服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息。
很适合用在社交应用这种场景。django本身是不支持websocket协议的，需要使用channels进行扩展，使用ASGI替换原来WSGI。
文字交流的实现比较简单。声音和图像的获取都通过前端JS从浏览器获取，获取之后后把视频流或音频流数据base64编码后传到WebSocket服务器，
然后根据具体的接收人进行转发。目前流程是基本打通了，不过距离实际使用还有一段距离。现在还有几个问题没有解决，一是视频聊天时延迟很高，图像比较卡顿。原因可能是直接把图像编码传输转发可能不是一个很好的方式。
二是现在只能进行局域网通信，没有做内网穿透。我查了一些资料，比较的主流方式是使用WebRTC技术。WebRTC是一项浏览器与浏览器之间的实时通讯技术，重点是在前端部分，我下一步优化方向也是往这个方向。

ID_photo
情境+任务：
在易宝工作期间，平时跟客户学习了一些图像算法的内容，这个项目是我为了巩固学的知识做的一个项目，主要是用来处理证件照。
项目前端用的qt，图像算法的处理使用的是opencv库。项目实现了一些证件照处理比较常用的功能，像裁剪、换底色、倾斜证件照矫正等。
我简单介绍一下换底色和图像矫正的原理。换底色，比较直接的思路就是把人像和背景分离，人像保持不变，对背景颜色进行替换。
这里用到一个HSV的颜色空间。一般我们用的颜色模式都是RGB模式，对一种颜色的表示通过红绿蓝三种颜色分量组合得来。所以对于某一种颜色，很难推测出较为精确的三个分量数值来表示。
但是HSV颜色空间不一样，只用1个分量H来表达颜色色调，S和V表示饱和度和明度。这样就比较容易确定一种颜色。假设有一张蓝底的照片，给它设置一个蓝色的颜色区间，把颜色在这个区间中的区域筛选出来，
填充成红色或者白色，这样就达到了一个换底的目的。图像矫正功能用到一个直线检测，像身份证证件这种一般来说都是矩形。先用霍夫变换检测出图像中所有直线位置，然后计算出每条直线倾斜角度，然后根据这个角度进行旋转图片即可。






面试题
匹配字符串的开头
^，match函数
匹配字符串的结尾
$

匹配电子邮件地址
Python正则表达式：\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+

这个正则表达式将匹配几乎所有标准的电子邮件地址。它首先寻找一个或多个由字母、数字或下划线组成的单词（\w+），
然后可能有一个或多个这样的单词被点或减号分隔（([.-]?\w+)*）。然后它寻找@符号，然后是另一个可能包含单词，点或减号的序列。
然后它寻找一个或多个由字母、数字或下划线组成的单词，然后是一个点，然后是两个或三个字母（(\.\w{2,3})+）。

匹配日期
Python正则表达式：(\d{4})-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])

这个正则表达式将匹配格式为YYYY-MM-DD的日期。首先，它寻找四位数的年份（\d{4}），然后是一个连字符，
然后是两位数的月份（这里使用了捕获组，所以月份的值可以从 $1 中获取），再是一个连字符，然后是两位数的日期。

匹配IP地址

Python正则表达式：(\d{1,3}\.){3}\d{1,3}

这个正则表达式将匹配四组数字，每组数字之间用点分隔。每个数字组可能是1到3位的数字（\d{1,3}），并且每个数字组都可能有一个点（.）。注意这个正则表达式并不能完全验证一个有效的IP地址，因为它没有检查数字的范围。要实现完整的验证，你需要使用更复杂的正则表达式或者编程逻辑。

匹配手机号码

Python正则表达式：1[34578]\d{9}

这个正则表达式将匹配以1开头，然后是3, 4, 5, 7, 8中的一个数字，然后是9位数字的手机号码。注意这个正则表达式可能不能完全匹配所有可能的手机号码，因为一些地区的手机号码可能会有所不同。例如，中国的手机号码通常以1开头，第二位通常是3-9的任意数字，然后是剩下的9位数字。

正则匹配手机号
import re

def validate_phone_number(phone_number):
    pattern = re.compile("^1[3-9]\d{9}$")
    if pattern.match(phone_number):
        return True
    else:
        return False

# 测试函数
print(validate_phone_number("13800138000"))  # 输出：True
print(validate_phone_number("12800138000"))  # 输出：False
在上述代码中，^1[3-9]\d{9}$是一个正则表达式，用于匹配以1开头，第二位为3-9之间的任意数字，然后是9个任意数字，总共11位的字符串。这与中国手机号的格式相符。

请注意，这个函数只会检查输入的格式是否与中国手机号相符，并不会检查该手机号是否真正存在。如果你需要验证手机号的真实性，可能需要访问一个包含有效手机号的数据库或使用其他服务。

匹配IP地址
在Python中，你可以使用正则表达式来匹配IP地址。以下是一个例子：

python
import re

def validate_ip(ip):
    pattern = r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
    if re.match(pattern, ip):
        return True
    else:
        return False

# 测试函数
print(validate_ip("192.168.1.1"))  # 输出：True
print(validate_ip("256.1.1.1"))  # 输出：False
这个正则表达式可以正确匹配IPv4地址的四个部分。每个部分都是一个在0-255之间的整数，每部分由"."分隔。

如果你需要匹配IPv6地址，你需要使用一个不同的正则表达式。
正则
\d数字\D非数字字符  \s空字符 \t制表符 \n换行符 .任意字符
re.match只匹配字符串的开始
re.search匹配整个字符串，直到找到一个匹配。
re.sub替换
Span，返回开始位置和结束位置
Findall    注意： match 和 search 是匹配一次 findall 匹配所有。re.I对大小写敏感
re*	匹配0个或多个的表达式。
re+	匹配1个或多个的表达式。
re?	匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式
[...]	用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'
[^...]	不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。


.	匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式。
\d	匹配一个数字字符。等价于 [0-9]。
\D	匹配一个非数字字符。等价于 [^0-9]。
\s	匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
\S	匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\w	匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。
\W	匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。


Python的执行原理（过程）
1、源代码编译：当Python代码在执行前，会被解释器进行词法分析和语法分析，以确保代码无误。然后解释器将源代码编译为字节码文件。
2、字节码解释执行：字节码文件是Python的中间代码，它可以被CPU直接识别并执行。当Python脚本需要被执行时，只需调用Python解释器并传入相应的字节码文件即可。

Python的内核是什么
python是C语言编写的。python是一种面向对象的动态类型语言，它的底层是用C语言写的，很多标准库和第三方库也都是用C语言写的；Python解释器易于扩展，可以使用C语言或C++（或者其他可以通过C调用的语言）扩展新的功能和数据类型。



# 使用 `*` 号操作解压
list1_unzip, list2_unzip = zip(*zipped_list)

print(list1_unzip)  # 输出: (1, 2, 3)
print(list2_unzip)  # 输出: ('a', 'b', 'c')
注意，zip()函数创建的是一个只能访问一次的迭代器，如果你尝试再次访问该迭代器，例如重新转化为列表，则会报错。如果你需要多次使用，可以先将它转化为列表或者其它的可迭代数据类型。
元组和列表的区别
列表是可变的动态序列，可以访问，并增加、删除和修改列表中的元素，支持切片操作；
元组是不可变的静态序列，可以访问、不可以增删改元组中的元素，同样支持切片操作。
元组可当字典键，列表不行
python列表常用成员方法
append，extend，insert,remove(只删除一个，删除第一个匹配的）, pop删除指定元素，
 count返回指定元素在列表中出现的次数，reverse，reversed，sort,sorted


python中，分别写一个filter，reduce，map的使用实例
1.	filter函数
filter函数用于对一个序列进行筛选，返回符合条件的元素组成的新序列。它的语法如下：
python复制代码
	filter(function, iterable)
其中，function是一个用于筛选元素的函数，iterable是一个可迭代对象。
示例：筛选出列表中所有偶数并返回新列表。
python复制代码
	my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]
	even_numbers = filter(lambda x: x % 2 == 0, my_list)
	print(list(even_numbers)) # 输出 [2, 4, 6, 8]
1.	reduce函数
reduce函数用于对一个序列进行归约操作，即将序列中的所有元素按照指定的规则进行累积计算，返回一个单一的结果。它的语法如下：
python复制代码
	reduce(function, iterable[, initializer])
其中，function是一个用于归约操作的函数，iterable是一个可迭代对象，initializer是可选参数，用于指定归约操作的初始值。
示例：计算列表中所有元素的乘积并返回结果。
python复制代码
	from functools import reduce
	my_list = [1, 2, 3, 4, 5]
	product = reduce(lambda x, y: x * y, my_list)
	print(product) # 输出 120
1.	map函数
map函数用于对一个序列中的每个元素应用指定的函数，并返回新序列。它的语法如下：
python复制代码
	map(function, iterable[, iterable2[, ...]])
其中，function是一个应用于每个元素的函数，iterable是一个或多个可迭代对象。
示例：将列表中的每个元素都平方并返回新列表。
python复制代码
	my_list = [1, 2, 3, 4, 5]
	squared_numbers = map(lambda x: x ** 2, my_list)
	print(list(squared_numbers)) # 输出 [1, 4, 9, 16, 25]


Python中可变和不可变对象
不可变对象包括：bool（布尔）、int（整数）、float（浮点数）、str（字符串）、tuple（元组）、frozenset（不可变集合），具有以下特性：
•	可 hash（不可变长度）
•	不支持新增
•	不支持删除
•	不支持修改
•	支持查询
可变对象
可变对象包括：list（列表）、set（集合）、dict（字典），具有以下特性：
•	不可 hash（可变长度）
•	支持新增
•	支持删除
•	支持修改
•	支持查询

什么是生成器、迭代器?
生成器和迭代器都是 Python 中的一种特殊类型的数据结构，它们都可以用于迭代操作，但有一些区别。

迭代器（Iterator）是一个可以记住遍历的位置的对象，它从集合的第一个元素开始访问，直到所有的元素都被访问一遍，迭代器只能往前不会后退。可以通过两种主要方法来创建迭代器：定义含有 __iter__() 和 __next__() 方法的类，或者使用 Python 的内建函数。

生成器（Generator）是一个使用 yield 关键字的函数，每次在函数中遇到 yield 时，函数就会从此处暂停并保存所有当前的信息，返回 yield 的值。当再次调用生成器函数时，它会从上次离开的地方开始执行。生成器的主要优点是它可以节省内存空间，因为它不需要一次性地生成所有的元素，而是在需要时才生成。

两者之间的主要区别在于，迭代器是一个可以记住遍历的位置的对象，而生成器是一个使用 yield 关键字的函数。此外，生成器可以节省内存空间，因为它不需要一次性地生成所有的元素，而是在需要时才生成。
class MyIterator:
    def __init__(self, start, end):
        self.current = start
        self.end = end

    def __iter__(self):
        return self

    def __next__(self):
        if self.current > self.end:
            raise StopIteration
        else:
            self.current += 1
            return self.current - 1
在这个例子中，MyIterator 类实现了一个迭代器，通过 __iter__() 方法返回自身，并通过 __next__() 方法逐步生成下一个元素，直到达到指定的结束值。可以通过 for 循环来使用这个迭代器，例如：

python
复制代码
my_iter = MyIterator(0, 5)
for i in my_iter:
    print(i)
输出结果为：

复制代码
0
1
2
3
4
接下来是一个生成器示例：

python
复制代码
def my_generator(start, end):
    current = start
    for i in range(start, end + 1):
        yield current
        current += 1
这个例子中，my_generator 函数是一个生成器，使用 yield 关键字逐步生成每个元素，并在下一次调用时从离开的地方继续执行。可以使用 for 循环来使用这个生成器，例如：

python
复制代码
for i in my_generator(0, 5):
    print(i)
输出结果和上面的迭代器示例相同：

复制代码
0
1
2
3
4
1.实现方式不同
生成器使用了yield语句来实现，而迭代器使用了类的魔法方法__iter__()和__next__()来实现。
2.生成方式不同
生成器可以逐个生成序列中的值，而迭代器一次性生成整个序列，将其存储在内存中。
3.执行方式不同
生成器像函数一样调用和执行，可以在每次迭代时产生和恢复值，而迭代器则按照序列的下一个元素依次执行。
4. 功能不同
生成器主要用于生成序列，而迭代器主要用于遍历序列。

深拷贝和浅拷贝
浅拷贝，改变原始对象中为可变类型的元素的值，会同时影响拷贝对象；改变原始对象中为不可变类型的元素的值，不会影响拷贝的对象。
深拷贝，除了顶层拷贝，还对子元素也进行了拷贝。经过深拷贝后，原始对象和拷贝对象所有的可变元素地址都没有相同的了。
深拷贝的问题：1、内存不足：如果被拷贝的对象树非常庞大，那么深拷贝可能会消耗大量的内存。由于深拷贝需要创建新的对象并存储在内存中，如果内存不足，就可能导致拷贝失败或者程序崩溃。
2、对于包含循环引用的对象，深拷贝可能会陷入无限递归，导致程序崩溃。
在深拷贝中，即使修改被引用的对象，深拷贝对象和原始对象的子对象之间也没有任何联系。
使用copy模块实现深拷贝和浅拷贝。
Copy()、deepcopy()
Python中append和extend的区别？
append() 向列表尾部追加一个新元素，列表只占一个索引位，在原有列表上增加
extend() 向列表尾部追加一个列表，将列表中的每个元素都追加进来，在原有列表上增加

Python中==和is的区别
is用于判断两个变量引用对象是否为同一个，==用于判断引用变量的值是否相等。
引用是内存中真实对象的指针,表示为变量名或内存地址
区分下break，continue和pass？
**break：**跳出循环，不执行下一个循环。同时break后面的代码也不会执行。
**pass：**pass后面的代码还是会继续执行，也就是当前的循环还在继续。
**continue：**continue后面的代码不会执行，而是直接进入下一个循环。

Python中的局部变量和全局变量是什么？
**全局变量：**在函数外或全局空间中声明的变量称为全局变量。这些变量可以由程序中的任何函数访问。
**局部变量：**在函数内声明的任何变量都称为局部变量。此变量存在于局部空间中，而不是全局空间中。

python装饰器是什么？
装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。
它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。
装饰器函数可以接受任意数量的参数，并返回一个新的函数。 在示例中，decorator函数是一个装饰器函数，它接受一个函数作为参数并返回一个新的函数wrapper。wrapper函数在调用原始函数之前和之后执行一些操作，然后调用原始函数并返回其结果。通过在原始函数上方使用@decorator语法，将原始函数装饰为经过装饰器修饰的新函数。



pandas函数汇总
Pandas库专为数据分析而设计，它是使Python成为强大而高效的数据分析环境的重要因素。
一、Pandas数据结构
1、import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
2、S1=pd.Series([‘a’,’b’,’c’]) series是一组数据与一组索引（行索引）组成的数据结构
3、S1=pd.Series([‘a’,’b’,’c’],index=(1,3,4)) 指定索引
4、S1=pd.Series({1:‘a’,2:’b’,3:’c’}) 用字典形式指定索引
5、S1.index() 返回索引
6、S1.values() 返回值
7、Df=pd.DataFrame([‘a’,’b’,’c’]) dataframe是一组数据与两组索引（行列索引）组成的数据结构
8、Df=pd.DataFrame([[a,A],[b,B],[c,C]],columns=[‘小写’,’大写’]，index=[‘一’,’二’,’三’])
Columms 为列索引，index为行索引
9、pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider 清华镜像
10、data={‘小写’:[‘a’,’b’,’c’],’大写’:[‘A’,’B’,’C’]} 传入字典
Df=Pd.DataFrame(data)
11、Df.index() df.columns()
二、读取数据
12、df=pd.read_excel(r’C:\user\...xlsx’,sheet_name=’sheet1’) 或
Pd.read_excel(r’C:\user\...xlsx’,sheet_name=0) 读取excel表
13、Pd.read_excel(r’C:\user\...xlsx’,index_col=0,header=0)
index_col指定行索引，header指定列索引
14、pd.read_excel(r’C:\user\...xlsx’,usecols=[0,1]) 导入指定列,不能有index_col和header
15、pd.read_tablel(r’C:\user\...txt’，sep=’ ’) 导入txt文件,sep指定分隔符是什么
16、df.head(2) 展示前两行，默认展示前5行
17、df.shape 显示数据几行几列，不包含行和列索引
18、http://df.info() 可查看表中数据的类型
19、df.describe() 可获得表中数值类型指端的分布值（和、平均值、方差等）
三、数据预处理
20、http://df.info() 可显示表中哪个数据为空
21、df.isnull() 方法可以判断哪个值是缺失值，如果缺失返回True，否则为False
22、df.dropna() 默认删除含缺失值的行
23、df.dropna(how=’all’) 删除全为空值的行，不全为空值的行不会删除
24、df.fillna(0) 用0填充所有空值
25、df.fillna({‘性别’:’男’,’年龄’:’30’}) 对性别列中空值填充男，年龄填充30
26、df.drop_duplicates() 默认对所有值进行重复值检查，保留第一行的值
27、df.drop_duplicates(subset=’性别’) 对性别列中重复值查询保留第一行
28、df.drop_duplicates(subset=[’性别’,’公司’]，keep=’last’) 对性别和公司两列查重
keep设置默认为first（保留第一个），可设置为last（保留最后一个） 或False(不部不保留)
29、df[‘ID’].dtype 查看ID列的数据类型
30、df[‘ID’].astype(‘float’) 将ID列的数据类型转换为float类型
31、数据类型：int、float、object、string、unicode、datetime
32、df[‘ID’][1] ID列的第二个数据
33、df.columns=[‘大写’,’小写’,’中文’] 为无索引表添加列索引
34、df.index=[1,2,3] 添加行索引
35、df.set_index(‘编号’) 指明要用的列作为行索列
36、df.rename(index={‘订单编号’:’新订单编号’,’客户姓名’:’新客户姓名’}) 对行索引进行重新命名
37、df.rename(columns={1:’一’,2:’二’}) 对列索引进行重新命名
38、df.reset_index() 默认将全部index转化为column
39、df.reset_index(level=0) 将0级索引转化为column
40、df.reset_index(drop=True) 删除原有索引
四、数据选择
41、df[[‘ID’,’姓名’]] 多个列名要装入list
42、df.iloc[[1,3],[2,4]] 用行列编号选择数据
43、df.iloc[1,1] 选取表中的第3行2列数据，第一行默认为列索引
44、df.iloc[:,0:4] #获取第1列到第4列的值
45、df.loc[‘一’] #loc用行名选取的行数据，格式是Series，但可以用列表形式访问
46、df.loc[‘一’][0] 或 df.loc[‘一’][‘序号’]
47、df.iloc[1]#iloc用行编号选取行数据
48、df.iloc[[1,3]]#多行编号选取行数据，要用list封装，不然变成行列选取
49、df.iloc[1:3]#选择第二行和第四行
50、df[df[‘年龄’]<45] #加判断条件返回符合条件的全部数据，不局限年龄列
51、df[(df[‘年龄’]<45)&(df[‘ID’]<4)] #判断多条件选择数据
52、df.iloc[[1,3],[2,4]] 相当于df.loc[[‘一’,’二’],[‘年龄’,’ID’]] #loc是名，iloc是编号
53、df[df[‘年龄’]<45][[‘年龄’,’ID’]]#先通过年龄条件选择行，再通过不同索引指定列
54、df.iloc[1:3,2:4]#切片索引
五、数值操作
55、df[‘年龄’].replace(100,33)#对年龄列中的100替换成33
56、df.replace(np.NaN,0)#相当于fillna(),其中np.NaN是python中缺省值的表示方式
57、df.replace([A,B],C)#多对一替换，A、B替换成C
58、df.replace({‘A’:’a’,‘B’:’b’,‘C’:’c’})#多对多替换
59、df.sort_values(by=['申请单编号'],ascending=False)#申请单编号列降序排列，Ture升序排列（默认）
60、df.sort_values(by=['申请单编号'],na_position=’first’)#申请单编号列升序排列，缺失值排在第一位
默认缺失值在最后一位last
61、df.sort_values(by=['col1',’col2’],ascending=[False,True])#多列排序
62、df[‘销量’].rank(method=’first’)#销量排名（不是排序），method有first\min\max\average
63、df.drop([‘销量’,’ID’],axis=1)#删除列,直接是列名
64、df.drop(df.columns[[4,5]],axis=1)#删除列,是编号
65、df.drop(colums=[‘销量’,’ID’])#此种方式删除列，可以不写axis=1
66、df.drop([‘a’,’b’],axis=0)#删除行,直接是列名
67、df.drop(df.index[[4,5]],axis=0)#删除行,是编号
68、df.drop(index=[‘a’,’b’])#此种方式删除行，可以不写axis=0
69、df[‘ID’].value_counts()#对ID列中数据出现的次数进行统计
70、df[‘ID’].value_counts(normalize=Ture,sort=False)#对ID列中数据出现的次数占比进行统计，并降序排序
71、df[‘ID’].unique()#获取列的唯一值
72、df[‘年龄’].isin([‘a’,11])#查看这列中是否包含a或11
73、pd.cut(df[‘ID’],bins=[0,3,6,10])#用bins指明切分区间
74、pd.qcut(df[‘ID’],3)#ID列切分成3个部分，每部分数据个数尽量一致
75、df.insert(2,’商品’,[‘书’,’笔’,’计算器’])#插入第三列
76、df[’商品’]=[‘书’,’笔’,’计算器’])#插新列，在表的最后面
77、df.T行列互换
78、df.tack()#把表格型数据转化成树形数据
79、df.set_index([‘ID’,’姓名’]).stack().reset_index()#宽表转换成长表，先将共同列设置成行索引，再对其他列
进行转化成树形数据，再重置行索引
80、df.melt(id_vars=[‘ID’,’姓名’],var_name=’year’,value_name=’sale’)#id_var参数指明宽表转换成长表时保持不
变的列，var_name参数表示原来的列索引转化为行索引对应的列名，value_name表示新索引对应值的列名
81、df[‘C1’].apply(lambda x:x+1)#相当于map(),只是需要和lambda配合
82、df.applymap(lambda x:x+1),对表中的所有数据执行相同函数运算
六、数据运算
83、df[‘ID’]+Df[‘ID’]#可进行加减乘除
84、df[‘ID’]>Df[‘ID’]#可进行> < == !=等比较运算
85、df.count()#统计每列的非空值的个数
86、df.count(axis=1)#统计每行的非空值的个数
87、df[‘ID’].count()#统计指定列的非空值的个数
88、df.sum(axis=1)#每列/行求和结果
89、df.mean(axis=1)#每列/行求均值
90、df.max(axis=1)#每列/行求最大值
91、df.min(axis=1)#每列/行求最小值
92、df.median(axis=1)#每列/行求中间值
93、df.mode(axis=1)#每列/行中出现最多的值
94、df.var(axis=1)#每列/行求方差
95、df.std(axis=1)#每列/行求标准差
96、df.quantile(0.25)#求1/4分位数，可以0.5、0.75等分位数
97、df.corr()#求整个DataFrame表中的相关性
七、时间序列
98、from datetime import datetime
99、datatime.now()#返回现在的时间年月日时分秒
100、datatime.now().year#返回年，可以.month\.day
101、datatime.now().weekday()-1#返回周几
102、datatime.now().isocalendar()#返回周数
103、 （2018，41，7）#2018年的第41周第7天
104、datatime.now().date()#只返回年月日
105、datatime.now().time()#只返回时间
106、datatime.now().strftime(‘%Y-%m-%d %H:%M:%S’)#返回2020-03-13 09:09:12
107、from dateutil.parer import parse
108、 parse(str_time)#将字符串的时间转化成为时间格式
109、pd.Datetimeindex([‘2020-02-03’,2020-03-05’])#设置时间索引
110、data[‘2018’]#获取2018年的数据
111、data[‘2018-01’]#获取2018年1月的数据
112、data[‘2018-01-05’:‘2018-01-15’]#获取这个时段的数据
113、非时间索引的表格处理
114、df[df[‘成交时间’]==datetime(2018,08,05)]
115、df[df[‘成交时间’]>datetime(2018,08,05)]
116、df[(df[‘成交时间’]>datetime(2018,08,05))&(df[‘成交时间’] <datetime(2018,08,15))]
117、cha=datatime(2018,5,21,19,50)-datatime(2018,5,18,17,50)
118、 cha.days#返回天的时间差
119、 cha.seconds#返回秒的时间差
120、 cha.seconds/3600#返回小时的时间差
121、datatime(2018,5,21,19,50)+timedelta(days=1)#往后移一天
122、datatime(2018,5,21,19,50)+timedelta(seconds=20)#往后移20秒
123、datatime(2018,5,21,19,50)-timedelta(days=1)#往前移一天
八、数据透视表
124、df.groupby(‘客户分类’).count()#客户分类后求数运算
125、df.groupby(‘客户分类’).sum()#客户分类后求和运算
126、df.groupby(‘客户分类’,’区域分类’).sum()#多列分类后求和运算
127、df.groupby(‘客户分类’,’区域分类’)[‘ID’].sum()#多列分类后ID求和运算
128、df[‘ID’]#DataFrame取出一列就是Series类型
129、df.groupby(df[‘ID’]).sum（） 相当于 df.groupby(‘ID’).sum（）
130、df.groupby(‘客户分类’).aggregate([‘sum’,’count’]# aggregate可实现多种汇总方式
131、df.groupby(‘客户分类’).aggregate({‘ID’：‘count’,’销量’： ‘sum’})
132、# aggregate可针对不同列做不同的汇总运算
133、df.groupby(‘客户分类’).sum().reset_index()#分组汇总后再重置索引，变为标准DataFrame
134、pd.pivot_table(data,values,index,columms,aggfunc,fill_value,margins,dropna,margins_name)
135、数据透视表，data:数据表df,values:值，index:行索引，columns:列索引，aggfunc:values的计算类型，fill_value:对空值的填充方式；margins:是否有合计列；margins_name:合计列的列名
136、pd.pivot_table(df,values=[’ID’,‘销量’],index=’客户分类’,columms=‘区域’,aggfunc={‘ID’：‘count’,’销量’：‘sum’}),fill_value=0,margins=Ture,dropna=None,margins_name=’总计’)
九、多表格拼接
137、pd.merge(df1,df2)#默认自动寻找两个表中的公共列进行拼接
138、pd.merge(df1,df2,on=“学号“)#on来指定连接列，连接列要是公共列
139、pd.merge(df1,df2,on=[‘学号’,’姓名’]#on来指定连接列，连接列要是公共列
140、pd.merge(df1,df2,left_on=‘学号’right_on=’编号’) #由公共列，但类名不同时用左右键指定
141、pd.merge(df1,df2,left_index=‘学号’right_index=’编号’)#两表公共列都是索引列时
142、pd.merge(df1,df2,left_index=‘学号’right_on=’编号’)#公共列一个时索引列一个时普通列
143、pd.merge(df1,df2,on=’学号’,how=’inner’)#返回公共列中对应的公共值拼接（内连接）
144、pd.merge(df1,df2,on=’学号’,how=’left’)#返回公共列中对应的左表值（左连接）
145、pd.merge(df1,df2,on=’学号’,how=’right’)#返回公共列中对应的右表值（右连接）
146、pd.merge(df1,df2,on=’学号’,how=’outer’)#返回公共列中对应的所有值（外连接）
147、pd.concat([df1,df2])#两个结构相同的表纵向连接，保留原索引值
148、pd.concat([df1,df2]，ignore_index=True)#两个结构相同的表纵向连接，重新设置索引值
149、pd.concat([df1,df2]，ignore_index=True).drop_duplicates()#拼接后去掉重复值
十、导出文件
150、df.to_excel(excel_writer=r’C:\users\zhoulifu\Desktop\测试.xlsx’)#导出文件格式.xlsx用to_excel方法，通过excel_writer参数来实现
151、df.to_excel(excel_writer=r’C:\users\zhoulifu\Desktop\测试.xlsx’,sheet_name=’文档’)
152、df.to_excel(excel_writer=r’C:\users\zhoulifu\Desktop\测试.xlsx’,sheet_name=’文档’，index=False)#导出是去掉索引
153、df.to_excel(excel_writer=r’C:\users\zhoulifu\Desktop\测试.xlsx’,sheet_name=’文档’，index=False,columns=[‘ID’,’销量’,‘姓名’])#设置导出的列
154、df.to_excel(excel_writer=r’C:\users\zhoulifu\Desktop\测试.xlsx’,sheet_name=’文档’，index=False,columns=[‘ID’,’销量’,‘姓名’],encoding=’utf-8’)#设置导出的列
155、df.to_excel(excel_writer=r’C:\users\zhoulifu\Desktop\测试.xlsx’,sheet_name=’文档’，index=False,columns=[‘ID’,’销量’,‘姓名’],encoding=’utf-8’,na_rep=0)#缺失值填充
156、writer=pd.ExcelWriter(excelpath,engine=’xlsxwirter’)#导出多个文件至一个文件的多个sheet
157、df1.to_excel(writer,sheet_name=‘表一’)
158、df2.to_excel(writer,sheet_name=’表二’)
159、writer.save()



列举常见的内置函数
Input()输入、print()输出、id()内存地址，type()类型，int、float、list、tuple、dict
Zip()打包，min,max
range函数和xrange
range和xrange都在循环时用的比较多，下面来分析一下他们在循环里面的各自表现：
如果循环时用range，由上面结果我们也可以看出，上来就会生成一个数组。若是元素个数少还可以接受，但是如果元素个数非常多，那岂不是要开辟很大的内存来存放这个数组？这对让内存空间亚历山大呀。
如果使用xrange，xrange返回的是一个生成器，一边循环一边计算，每次只返回一个值，这样就不必开辟这么大的内存空间了。
因此，在循环里尽量使用xrange吧，随着元素个数增多，xrange性能要比range好的多。

注意，在python3.x中，xrange被废除了，range功能跟xrange相同。
set类型的特点
set是一种无序的、不重复的元素集。不能通过索引获取元素。正则匹配不是4和7结尾的手机号
\d{10}[0-35-68-9]
Python变量、函数、类的命名规则？
(1)不能以数字开头，不能出现中文。
(2)命名以字母开头，包含数字，字母（区分大小写），下划线。
(3)不能包含关键字，见名知意。
1、类
单词首字母总是大写，私有类可以下划线开头。如MyClass。
2、函数
函数名一律小写，若有多个单词用下划线隔开。另外，私有函数下划线开头 。

3、变量
变量名最好小写，若有多个使用下划线分开 。
常量使用全大写，多个单词使用下划线隔开 。
python字符串处理
len方法：字符串长度
Upper、lower：大小写
Repalce：替换
Strip：去除
Startswith、endswith：开始、结尾
Split：分割

闭包

闭包定义：在函数嵌套的前提下，内部函数使用了外部函数的变量，并且外部函数返回了内部函数，我们把这个使用外部函数变量的内部函数称为闭包
闭包的构成条件：\n\n在函数嵌套（函数里面在定义函数）的前提下\n\n内部函数使用了外部函数的变量（还包括外部函数的参数）\n\n外部函数返回了内部函数\n\n3.闭包书写步骤：\n\n定义外部函数\n\n定义外部函数，在内部函数中使用外部函数的变量\n\n外部函数返回内部函数的地址
Python中的闭包是指在一个函数内部定义了另外一个函数，并返回了这个内部函数作为函数对象，同时保存了外层函数的状态信息。这个内部函数可以依赖外层函数的变量和参数，而且外层函数返回的是这个内部函数的引用。这种在函数内部定义函数并返回的方式称为闭包。

下面是一个简单的Python闭包示例：

python
def outer_func(x):
    def inner_func(y):
        return x + y
    return inner_func

closure = outer_func(10)
result = closure(20)

print(result)  # 输出 30
在上面的例子中，outer_func()是一个外部函数，它接受一个整数参数x，并返回了inner_func()函数对象。inner_func()是一个内部函数，它接受一个整数参数y，并返回x + y的结果。在outer_func()函数执行完毕后，它返回了inner_func()的引用，同时保存了x的状态信息。我们将这个返回的函数对象赋值给closure变量。接下来，我们使用closure变量来调用inner_func()函数，并将20作为参数传递给它。最终，它返回了30，这是10 + 20的结果。因此，我们可以通过闭包来保存和共享状态信息，以及定义可调用的函数对象。

装饰器、闭包、回调函数区别？
装饰器、闭包和回调函数是 Python 中的重要概念，它们之间有一些区别和相似之处。

装饰器（Decorator）：装饰器是 Python 中的一个功能强大的特性，用于修改或增强函数、方法或类的行为。装饰器本质上是一个接受函数作为参数的可调用对象（通常是一个函数），并返回一个新的函数。装饰器通常用于添加日志记录、性能测试、事务处理等功能，而不需要修改原始代码。
示例：

python
def my_decorator(func):
    def wrapper():
        print("Before function call")
        func()
        print("After function call")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
输出：

Before function call
Hello!
After function call
闭包（Closure）：闭包是指一个函数内部定义的函数，内部函数可以访问外部函数的局部变量和参数，即使外部函数已经执行完毕。闭包通常用于封装和隐藏内部状态，实现函数工厂和函数生成器等。
示例：

python
def outer_func(x):
    def inner_func(y):
        return x + y
    return inner_func

closure = outer_func(10)
result = closure(20)
print(result)  # 输出 30
回调函数（Callback Function）：回调函数是一种通过将函数作为参数传递给其他代码，以便在特定情况下（如事件触发或条件满足）执行的编程技术。回调函数通常用于异步编程、事件驱动编程和异步 I/O 等场景。在 Python 中，回调函数可以作为参数传递给其他函数或作为对象的方法。
示例：

python
def my_callback(arg):
    print("Callback called with", arg)

def call_callback(callback, arg):
    callback(arg)

call_callback(my_callback, "Hello")  # 输出 "Callback called with Hello"
区别：

装饰器通常用于修改或增强函数、方法或类的行为，而闭包主要用于封装和隐藏内部状态，回调函数主要用于异步编程和事件驱动编程。
装饰器需要显式地应用到函数或类上，而闭包和回调函数可以作为参数传递给其他函数或方法。
装饰器和闭包都是 Python 中的重要特性，而回调函数是一种通用的编程技术，不仅仅限于 Python。



数据类型可以分为6类
可变：列表、字典、集合
不可变：数值型、字符串、元组
不可变原因：分配了固定的内存空间，在这个对象的生命周期内不会改变
数据类型转换？
数值内部转换
Int-float  float()
Float-int  int()
转为字符串类型
字符串，数值 - 直接使用str方法
元组、列表和集合 使用join（）函数
转成元组
字符串、列表、集合、字典 —— tuple函数
转成集合
字符串、列表、列表、元组、字典 ——set函数
python类的私有属性是什么
类的私有属性是以双下划线（__）开头的属性。这种属性只能在类的内部访问，而不能在类的外部访问。
在类的内部，可以通过_类名__属性名的方式来访问私有属性

python有GIL，那多线程为什么还能加快速度？
1、I/O密集型任务：对于I/O密集型任务，如网络请求或文件读写，多线程可以显著提高效率。当一个线程在等待I/O操作完成时，其他线程可以继续执行其他任务。
2、计算密集型任务：虽然Python的GIL限制了多线程的并行计算能力，但是，可以通过使用Python的multiprocessing模块来在多个进程之间分配计算密集型任务，从而实现并行计算。
3、异步编程：Python的asyncio库可以实现单线程并发执行多个任务，这种方式避开了GIL的限制，可以充分利用多核CPU的性能。
4、阻塞型任务：对于可能会阻塞的任务，如网络请求或I/O操作，使用多线程可以避免这些阻塞影响主线程的执行。
5、数据并行：在处理大量数据或并行数据集时，可以使用多线程来分割任务，每个线程处理一部分数据，然后再将结果合并。总的来说，虽然Python的GIL限制了多线程的并行计算能力，但在许多情况下，使用多线程仍然可以显著提高程序的性能。

有序数据类型？
字符串、列表、元组

逆序方法
字符串：切片、reverse()、for循环
列表：切片、reverse()、reserved
元组：reversed、切片

reversed和reverse
Reverse是在原对象上修改
Reversed是一个新对象，并且要转成对应的类型

全局变量和局部变量
全局：全局范围
局部：函数内部或者类内部
可以通过关键词global修饰成全局变量
接口是什么？如何实现？
在Python中，接口是一种约定或合同，它定义了一个类应该具有哪些方法，但并不指定方法的具体实现。接口本身并不包含任何实现代码，它只是定义了一个类应该具有哪些方法。
Python中的接口通常使用抽象基类（Abstract Base Class，ABC）来实现。抽象基类是一种特殊的类，它不能被实例化，只能被继承。抽象基类可以定义一些抽象方法，这些方法没有具体的实现，只有方法签名。子类必须实现这些方法才能被实例化。



python中类方法、类实例方法、静态方法有什么区别？
实例方法：类实例方法是定义在类中，并且没有被任何装饰器修饰的方法。它们需要通过类的实例才能调用。第一个参数通常是self

类方法：可以通过类本身调用，不需要实例化，用装饰器@classmethod修饰，实例对象也可以调用，第一个参数通常是cls

静态方法：被装饰器@staticmethod修饰的方法，可以直接调用，也可以被实例化对象调用。静态方法与其他两种方法的区别在于它们不接受特殊的cls或self参数。因此，静态方法无法访问类或实例的属性。它们通常用于执行与类无关的操作，例如工具函数或辅助函数。

什么是面向对象的编程？
面向对象的编程语言，将功能转换为一个个对象，比较符合人们的思维习惯，便于理解，也具有很强的移植性与扩展性。
面向对象具有封装、继承、多态三大特征，其中封装与多态的实现都要依赖继承。
封装的作用是为用户提供一个接口，用户使用该接口操作数据，访问内部功能。用户不需要知道内部的细节与具体实现步骤。
继承的作用是子类可以继承父类的属性或函数，可以提高代码的使用率，减少重复代码的书写。
多态的作用是不同子类根据自身的具体需求对于父类方法进行重构，这样可以使用相同的函数名实现不同的功能效果。
使用一个现实生活中的问题来区别面向过程与面向对象：中午要吃一顿红烧肉，使用面向过程的方式，就是买红烧肉的材料、处理材料、做红烧肉、吃红烧肉，逐步实现，需要知道具体的实现步骤与细节。采用面向对象的方式，就是定个红烧肉外卖、吃红烧肉，不需要知道具体的实现步骤与细节。


lambda表达式（匿名函数）的格式和应用场景？
匿名函数是指定义函数时没有定义函数名称的函数。匿名函数只有在调用时，才会创建作用域对象及函数对象，它未调用时不占用空间，调用时才占据空间，执行完毕立即释放，因此可以节约内存。
python中经常使用的8个模块？

函数与方法的区别？
1.声明的位置不同 方法是声明在类的内部，函数是声明在类的外部。
2.调用方式不同 方法的调用一般是通过实例化对象加上方法名的形式调用，如实例化对象.方法名(参数，...)。函数的调用通常是直接使用函数名的方式调用，如函数名(参数，...)。
3.声明的方式不同 函数的声明方式为def函数名(参数，...)，其中形参可以设置也可以省略。方法的声明方式为def方法名(self，参数，...)，方法的声明相比函数多了一个默认的“self”参数，除了静态方法，其他方法都需要设置这个默认参数。
pass语句的作用？
占位作用 在进行框架构建时，类或者方法内部具体逻辑还没实现，可以使用pass语句进行占位。
2.空语句 在if语句中对于一些分支不需进行操作，可以使用pass语句来实现效果。


回调函数？
回调函数是一个被作为参数传递给其他代码的函数。
time.strftime()#将时间转化为字符串格式
def my_callback(arg):
    print("回调函数被调用了，参数是: ", arg)
def call_callback(callback, arg):
    callback(arg)
# 调用函数，并将回调函数作为参数传递
call_callback(my_callback, "Hello, world!")
哪些类型的数据可以当函数参数？

在Python中函数的参数支持多种类型，可以分为基本数据类型、函数类型、对象类型。
基本数据类型 基本数据类型是函数常用的参数类型，根据数据是否可变，分为两种情况：不可变数据类型、可变数据类型。不可变数据类型有数值型、字符串型、元组类型，这3种数据类型的参数在调用时采用的是值传递方式；可变数据类型有列表型、字典型、集合型，这3种数据类型的参数在调用时采用的是引用传递方式。
函数类型 Python中可以将函数作为参数传递给另一个函数使用。该类型参数在回调函数中应用较多


3.实例化对象 Python也可以将一个实例化对象作为参数传递给一个函数使用。


字典排序
在Python中，字典（dict）本身是无序的。但是，可以使用内置的函数sorted()和lambda函数对字典进行排序。这里有一些示例。
按照键（key）排序：
python
d = {'a': 10, 'b': 5, 'c': 20, 'd': 15}
sorted_d = dict(sorted(d.items()))
print(sorted_d)  # 输出：{'a': 10, 'b': 5, 'c': 20, 'd': 15}
按照值（value）排序：
python
d = {'a': 10, 'b': 5, 'c': 20, 'd': 15}
sorted_d = dict(sorted(d.items(), key=lambda item: item[1]))
print(sorted_d)  # 输出：{'b': 5, 'a': 10, 'd': 15, 'c': 20}
在上述两个例子中，sorted()函数的key参数用于指定排序的标准。
lambda函数被用来指定我们需要按照键或者值来排序。
lambda item: item[0]表示按照键排序，lambda item: item[1]表示按照值排序。
注意，这些方法会返回一个新的有序字典，而不会改变原始的字典。
如果你希望改变原始字典的顺序，你需要重新赋值。
Python 3.7以后的版本，字典已经是有序的，这意味着插入键值对的顺序会被记住，
但是按照字典的值或者键排序仍然需要像上面这样操作。

映射函数map生成列表或集合
在Python中，map()函数是一种内置函数，用于将一个函数应用于一个（或多个）可迭代对象的所有元素。
map()函数返回一个map对象，这是一个迭代器，包含了所有函数处理后的结果。
如果你想使用map()函数来生成一个列表或集合，你可以这样做：
生成列表：
python
def square(n):
    return n*n

numbers = [1, 2, 3, 4, 5]
squared = map(square, numbers)
# map对象转换为列表
squared_list = list(squared)
print(squared_list)  # 输出：[1, 4, 9, 16, 25]
在这个例子中，我们定义了一个函数square()，然后用map()函数将square()函数应用于numbers列表的每一个元素。
最后，我们使用list()函数将map对象转换为列表。
2. 生成集合：
python
def square(n):
    return n*n
numbers = [1, 2, 2, 3, 4, 4, 5, 5]
squared = map(square, numbers)

# map对象转换为集合
squared_set = set(squared)
print(squared_set)  # 输出：{1, 4, 9, 16, 25}
在这个例子中，我们用map()函数将square()函数应用于numbers列表的每一个元素。
然后，我们使用set()函数将map对象转换为集合，集合会自动去除重复的元素。
两个列表/元组合并成字典
#列表合并为字典
# list_key=['name','age','sex']
# list_value=['小明',18,'男']
# dict_new=dict(zip(list_key,list_value))
# print(dict_new)

#元组合并为字典
tuple_key=('name','age','sex')
tuple_value=('小明',18,'男')
dict_new=dict(zip(tuple_key,tuple_value))
print(dict_new)
排序sort()和sorted()
在Python中，sort()和sorted()都是用于排序的函数，但它们有一些不同之处。
sort()是列表对象的一个方法，它会对原列表进行就地排序，即改变原列表的顺序。例如：
python复制代码
	lst = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
	lst.sort()
	print(lst) # 输出：[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]
sorted()`则是一个内置函数，它会返回一个新的已排序的列表，而不会改变原来的列表。例如：
python复制代码
	lst = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
	new_lst = sorted(lst)
	print(new_lst) # 输出：[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]
	print(lst) # 输出：[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
可以看到，sort()会直接修改原列表，而sorted()则会返回一个新的排序后的列表。因此，如果你需要保留原列表的顺序，可以使用sorted()函数。
sort()和sorted()函数在Python中主要用于对序列类型的数据进行排序，包括：
列表（list）
元组（tuple）
字符串（str）
集合（set）中的元素（但集合本身是无序的）
这两个函数不适用于字典（dict）类型的数据，因为字典的键值对是无序的。

集合列表的区别
创建方式不同 集合通过“{}”或set()创建，列表通过“[]”或list()创建。
2.排序方式不同 集合中的元素是无序排列，列表中的元素是有序排列。
3.元素是否重复 集合中的元素不能重复，列表中的元素可以重复。

交换字典的键和值
dict_old={'a':3,'b':2,'c':1}
dict_new={value:key for key,value in dict_old.items()}
print(dict_new)

字符串格式化
在 Python 中，您可以使用多种方法来格式化字符串。以下是几种常用的方法：
使用 % 运算符：
python复制代码
	name = "John"
	age = 30
	print("My name is %s and I'm %d years old." % (name, age))
使用 str.format() 方法：
python复制代码
	name = "John"
	age = 30
	print("My name is {} and I'm {} years old.".format(name, age))
使用 f-strings（在 Python 3.6 及更高版本中可用）：
python复制代码
	name = "John"
	age = 30
	print(f"My name is {name} and I'm {age} years old.")
以上三种方法都可以用来格式化字符串，您可以根据自己的喜好和具体需求选择使用哪种方法。
字符串编码和解码
在 Python 中，字符串的编码和解码是非常常见的操作。这是因为计算机中的数据最终以二进制的形式存储，而字符串通常需要以某种编码（如 UTF-8，ASCII 等）转换为二进制格式才能存储和传输。
Python 3 默认使用 UTF-8 编码。
编码：将字符串转换为字节流的过程称为编码。
解码：将字节流转换为字符串的过程称为解码。
下面是 Python 中字符串编码和解码的一些示例：
python复制代码
	# 字符串编码为字节流
	s = "你好, 世界"
	b = s.encode('utf-8') # 使用 UTF-8 编码
	print(b) # 输出: b'\xe4\xbd\xa0\xe5\xa5\xbd, \xe4\xb8\x96\xe7\x95\x8c'

	# 字节流解码为字符串
	s2 = b.decode('utf-8') # 使用 UTF-8 解码
	print(s2) # 输出: '你好, 世界'
.*和.*?的区别
.*：表示匹配任意数量的字符（包括零个字符），直到遇到换行符或者正则表达式的结尾。它是贪婪的，会尽可能多地匹配字符。
.*?：表示匹配任意数量的字符（包括零个字符），直到遇到换行符或者正则表达式的结尾。它是非贪婪的，会尽可能少地匹配字符。


匹配中文
# 使用正则表达式匹配中文字符
# \u4e00-\u9fa5 是 Unicode 范围内的中文字符
import re

# 要匹配的字符串
text = "这是一个用Python编写的示例，用于匹配中文字符。"

# 使用正则表达式匹配中文字符
# \u4e00-\u9fa5 是 Unicode 范围内的中文字符
pattern = re.compile(r'[\u4e00-\u9fa5]+')
# 查找所有匹配项
matches = pattern.findall(text)
# 输出匹配结果
for match in matches:
print(match)
如何检测字符串中是否只含有数字？
isdigit()，isnumeric() 或 isdecimal()

Match、search、findall的区别
match()函数的用法为re.match（'目标字符'，指定字符串），该函数进行匹配时是从指定字符串的开始位置进行匹配，如果没有匹配到，则返回None；如果匹配到，则返回一个Match Object类型的匹配对象，其中包含匹配到字符串的内容、位置索引等信息，可以使用group()函数获取匹配对象中匹配字符串的内容。

search()函数的用法为re.search（'目标字符'，指定字符串），该函数进行匹配时可以从指定字符串的任意位置进行匹配，如果没有匹配到，则返回None；如果匹配到，则返回一个Match Object类型的匹配对象，其中包含匹配到字符串的内容、位置索引等信息，可以使用group()函数获取匹配对象中匹配字符串的内容。

findall()函数的用法为re.search（正则表达式，指定字符串），该函数进行匹配时，会将所有符合要求的字符进行截取，以列表的形式返回。


python内存管理
Python中的内存管理通过引用计数机制、垃圾回收机制、内存池机制三个方面来实现。
1.	引用计数机制 引用计数是Python用来追踪记录内存中的对象，每个对象都会拥有一个相对应的引用计数。一般创建一个变量、生成一个对象、容器（字典、列表等）中元素的增加、作为参数传递给函数等操作都会导致引用计数增加。重新赋值、删除、超出作用域等操作都会导致引用计数减少。
2.	垃圾回收机制
垃圾回收是 ，主要解决对象之间的循环引用问题。当对象之间存在循环引用时，引用计数无法将对象从内存中释放出来，这时垃圾回收机制会扫描所有对象，将不可达的对象释放掉。
计算机中的内存不是无限制的，而是越用越少，当一些对象执行完毕后需要回收，释放它占用的内存，否则会影响计算机的性能。 一个对象被创建时也创建相应的引用计数，引用计数为1，当这个对象使用后，没用时，引用计数减少为0，Python中的垃圾收集器会查找引用计数为0的对象，释放它们占用的内存。但是引用计数回收方式存在一些问题。 例如下面的代码：

 上述代码执行的最终结果是，list1与list2这两个变量均被删除，但是它们的引用计数都为1，不为0，不会被垃圾收集器回收，导致内存一直被占用，这种情形称为循环引用。 Python中可能造成循环应用的数据类型有字典、列表、集合、对象。为了解决循环引用，可以采用标记-清除与分代回收两种方式。
标记-清除方式是在原有的双向存储链表以外再新增一个双向循环列表。这个循环列表用来存储可能发生循环引用的对象，如图6-1所示。  图6-1　标记-清除方式 在标记-清除方式中，除了原始的循环链表，又创建了一个新的双向循环链表，这个新循环链表中只存放可能造成循环引用的对象（字典、列表等）。以上述代码为例，list1和list2相互引用它们的引用计数为2，执行删除操作后，list1与list2的引用计数都减小为1，引用计数不为0，垃圾收集器无法释放这两个对象。在新循环链表中，list1与list2与原循环链表中的list1与list2指向的内存地址一致，所以，它们的引用计数当前也为1，但是新循环链表在一定的条件下会循环遍历链表中的所有元素，并将它们的引用计数都减小1。当元素的引用计数减小为0时，垃圾收集器就会清除这个对象，释放占用的内存。标记-清除方式解决了循环引用的问题，但是触发条件不确定，较为耗时，而且一次链表比较麻烦，效率较低。
分代回收是在标记-清除的基础上改进的，它解决了标记-清除触发条件不确定、效率较低的问题。分代回收是在原有双向循环链表的基础上新增3个循环链表，这3个新循环链表分别被称为0代、1代和2代。一般，当0代链表中的对象达到700时，会对0代链表进行遍历，其中所有对象的引用计数减1，然后将引用计数为0的对象删除回收，不为0的对象转移到1代链表中，此时0代链表为空，0代链表的遍历次数增加1个对象，0代链表需要重新存入对象，直至再次达到700个对象。每当0代链表遍历10次，1代链表遍历1次时，将1代链表中引用计数为0的对象删除回收，不为0的对象转移到2代链表中。1代链表遍历10代，2代链表遍历1次。分代回收可以避免过早删除某个可能使用的对象。

3.内存池机制
内存池是 Python 内存管理机制的优化策略，用来避免 Python 内存管理机制频繁地向操作系统申请和释放内存。Python 通过内存池预先申请一块较大的内存，然后将其划分为多个大小相等的内存块，避免频繁地向操作系统申请和释放内存。

创建一个对象时，先申请内存中的一块区域，然后在这块区域中存储对象的数据。回收对象时，首先删除这个对象名称，然后释放对象占用的内存。当重复进行小内存对象的删除操作时，大量的时间会花费在开辟内存与销毁内存上，为了提高执行效率，引入了内存池，Python解释器在运行时会直接开辟一块内存，用于小内存对象的使用。在内存池中默认会创建一些常用的数值或数据类型。当创建一个变量a=1时，不会直接在内存中开辟空间进行存储，而是在内存池中进行分配，当这个对象删除时，它占用的内存不会被释放，而是归还给内存池，当再创建一个变量b=2时，会从内存池中分配创建。内存池的好处是尽量少开辟内存、销毁内存，以内存块的形式进行管理，优先使用内存池中的空间，内存池不够用时再申请新的内存空间，这样可以减少内存资源的浪费，减少内存碎块的产生。




什么是进程线程协程？
进程：是操作系统进行资源分配的基本单元，是CPU对程序的一次执行过程。每个进程都是独立的，有自己的内存空间、数据栈等。在Python中，可以使用multiprocessing模块来创建和管理进程。

线程：被包含在进程之中，是操作系统进行程序调度执行的最小单元。一个进程中至少有一个线程，而多个线程共享内存（数据共享，共享全局变量)，可以极大地提高程序的运行效率。在Python中，可以使用threading模块来创建和管理线程。

协程：是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈，通过协程调度时，可以将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，可以不加锁的访问全局变量，所以上下文的切换非常快。协程的特点是比线程更小，单个线程上执行多个任务，可以在不同任务之间进行切换，以执行效率高著称。在Python中，可以使用asyncio模块来创建和管理协程。

什么是多线程？如何实现多线程？
在Python中，多线程是指程序中有多个线程同时执行的过程。一个线程可以看作程序中的一个执行路径，而多线程则允许程序同时执行多个任务。
Python中的多线程是通过标准库中的threading模块来实现的。该模块提供了创建和管理线程的功能，包括创建线程对象、启动线程、等待线程结束等。
使用多线程可以提高程序的执行效率，因为多个任务可以同时进行。例如，在一个需要执行大量计算任务的程序中，可以将计算任务分配给多个线程，这样程序就可以在更短的时间内完成任务。同时，多线程也可以改善程序的用户体验，因为可以在后台启动一个线程来处理耗时任务，而不会阻塞主线程的执行。
然而，需要注意的是，多线程也带来了一些复杂性。例如，线程之间的数据共享和同步问题需要特别注意。如果不正确地处理这些问题，可能会导致数据不一致或竞争条件等问题。因此，在使用多线程时，需要仔细考虑线程之间的交互和数据共享问题。

线程进程的区别？
在Python中，线程和进程的主要区别如下：

1、地址空间和其他资源：进程之间相互独立，每个进程都有自己独立的地址空间和其他资源（如打开的文件）。同一进程内的各线程间共享进程的地址空间和资源，某个进程内的线程在其他进程中不可见。
2、通信方式：进程间的通信（IPC）通常需要经过操作系统的中间代理实现，比如使用管道、消息队列、信号量等机制。而线程间可以通过读写进程数据段（如全局变量）来进行通信，但需要进程同步和互斥手段的辅助，以保证数据的一致性。
3、创建方式：在Python中，可以通过multiprocessing模块创建新的进程。而线程的创建和管理则通过threading模块实现。虽然线程可以被看作是一种特殊的进程，但在使用上还是存在一定的差异。
调度和执行：在多线程的操作系统中，通常在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位。线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。不同进程中的线程也能并发执行，但进程只能操作子进程，不能直接访问其他进程中的线程。
4、交互性：同一个进程里的线程之间可以直接访问，可以控制和操作同级线程里的其他线程。而不同进程之间的线程或进程要通信必须通过一个中间代理来实现。
综上所述，线程和进程在Python中都是实现并发执行的方式，但它们在地址空间、资源、通信方式、创建方式、调度和执行以及交互性等方面都存在一定的差异。根据实际应用场景选择合适的并发执行方式可以提高程序的执行效率、改善用户体验并充分利用和发挥处理机和外围设备并行工作的能力。

什么是协程？有哪些优缺点？
协程又称微线程，它也是一种程序组件，是一个比线程更小的执行单元。协程使用时，需要用户来编写调度机制，协程进行切换时由程序自身进行调度。协程中有自身的寄存器上下文和栈，当协程切换时可以恢复之前的寄存器上下文和栈，使协程恢复到之前调用时的状态。不需要像进程或线程那样需要进行加锁与解锁操作。
协程的优点如下：
①无须进行线程或进程中的上下文切换，开销较少。
(进程或线程上下文：上下文包括进程的代码、数据、堆、栈、文件描述符等信息）
②无须加锁、解锁操作。
③由程序主动控制协程切换。
④具有高并发、高扩展性，资源消耗少，运行效率高。
协程的缺点如下：
①协程只能在单核上运行，无法利用CPU多核的优势。
②发生阻塞操作时会造成整个程序的阻塞。
(阻塞：当我们在协程中执行某些阻塞操作时，例如进行网络请求、读写文件等，这会导致整个协程被阻塞，无法执行其他任务。这就是所谓的“阻塞操作”。）

线程和进程的使用场景？
进程是计算机系统进行资源分配的最小单位，它具有独立的内存空间，创建与切换的开销较大。
线程是用于调度执行的最小单位，它不具有独立的内存空间，同一进程下的线程共享内存空间，创建与切换的开销较少。
在Python中由于GIL（全局解释器锁）的存在，线程只能在CPU的一个核心上运行，因此无法实现真正意义上的并行，只能通过并发实现一种伪并行。进程不受GIL的限制，可以在CPU的多个核心上同时运行，充分利用CPU的多核优势，实现真正意义上的并行。
经过大量测试发现，
多进程更适用于计算密集型的操作，可以充分发挥CPU多核的计算优势。
多线程更适用于I/O密集型的操作，消耗的资源较少。


什么是全局解释器锁GIL
在Python中，全局解释器锁（GIL）本质上是一个互斥锁，它是在解释器（CPython）层面上的锁。Python语言设计之初，计算机广泛使用的还是单核CPU，为了解决多线程之间的数据完整与状态同步问题，最简单的方法就是加锁，每个线程在运行前都需要获取一把锁，从而保证同一时刻只能有一个线程运行，这把锁就是全局解释器锁。
GIL确保了一个进程中同一时刻只有一个线程运行，多线程在实际运行中只调用了一个CPU核心，无法使用多个CPU核心，因此多线程不能在多个CPU核心上并行，面对计算密集型的操作时，无法利用CPU的多核优势，运行效率较低。但是GIL对于单线程及I/O密集型的多线程运行没有影响。Python中的每个进程都有自己的解释器，因此，多进程不受GIL的限制，可以在CPU的多个核心上并行，多进程适合计算密集型的操作，但是进程的开销较大，不适用于I/O密集型的操作。
GIL不是Python的缺陷，只是一种针对解释器的设计思想，其中使用GIL的解释器有CPython，未使用GIL的解释器有JPython。


多线程的性质以及多进程的参数传递方式？
在Python中由于GIL的存在，导致进程中同一时刻只能有一个线程运行，因此，多线程无法使用多个CPU核心实现并行，只能在单一CPU核心上实现并发。面对计算密集型操作多线程无法利用CPU多核优势，运行效率较低。 多进程不受GIL的影响，可以在多个CPU核心并行。进程与进程之间的数据彼此独立，多进程传递参数时可以通过multiprocessing.Value或multiprocessing.Array方式传递。

线程是并发还是并行？进程是并发还是并行？
在宏观层面，并发是指多个任务在同一时间段内完成，并行是指多个任务在同一时间点完成。因此，并发不强调同时性，而并行强调同时性。 在微观层面，并发通常是多个任务交由一个CPU进行处理，CPU将任务进行处理的时间划分为非常细小的间隔，CPU不断地轮询这些任务，每个任务每次执行一个时间间隔，因此，看起来这些任务是在同时处理。并行是指多个任务交由多个CPU进行处理，每个任务单独使用一个CPU，彼此之间相互独立，互不影响，可以同时进行处理。 在Python中由于GIL的存在，同一时刻一个进程中只能有一个线程运行，多个线程只能在一个CPU核心上交替运行，因此多线程是并发。 进程不受GIL的限制，多个进程可以在多个CPU核心中同时运行，因此多进程是并行。


什么是多线程的竞争？
进程与进程之间相互独立，每个进程都拥有自己的内存空间。线程不具有自己的内存空间，是进程的一个实例，一个进程中可以存在多个线程，这些线程共享进程的内存空间。当多个线程运行时，可能对内存空间中的资源进行抢占。例如，A、B两个人相当于两个线程，他们共用一个银行账户，银行账户中有500元，这个银行账户相当于进程内存空间中的共享资源，现在A、B同时去银行办理业务，他们看到的账户余额都是500元，A存100元，账户余额变为600元；B取出200元，账户余额变为300元。 这种情况就是发生了多线程的抢占，它们同时访问共享资源，进行操作，多线程抢占会导致数据错乱，运行结果出错。因此，为了保证线程安全，需要对共享资源加锁，保证同一时刻只有一个线程访问和操作共享资源，这样当A进行存钱时，B无法进行取钱操作，A存完钱，银行账户更新为600元后，B才能取钱，最终银行账户变为400元。

python中GIL的存在是解决多线程竞争的吗？
在Python中，GIL（全局解释器锁）的存在并不是为了解决多线程竞争问题，而是为了解决多线程并发执行时的问题。

Python中的GIL是一种防止多个线程同时执行Python字节码的机制。由于Python的全局解释器锁，同一时间只有一个线程可以在解释器中运行Python字节码。这意味着尽管你的电脑可能拥有多个CPU核心，并且Python支持多线程，但由于GIL的存在，Python程序在同一时间仍然只能在一个CPU核心上运行一个线程。这限制了Python的多线程并发性能，因此在需要CPU密集型任务的情况下，Python的多线程可能并不理想。
实际上，GIL的存在可能会导致多线程竞争问题。由于同一时间只有一个线程可以执行，当多个线程需要访问共享资源时，必须等待其他线程完成其任务。这可能导致一些线程长时间等待，从而增加了多线程竞争的可能性。
因此，为了解决多线程竞争问题，Python程序员需要使用一些技巧来避免GIL的限制。例如，可以使用线程锁来保护共享资源，或者使用线程安全的数据结构来避免竞争条件。此外，可以使用多进程来替代多线程，因为每个进程都有自己的解释器和内存空间，可以避免GIL的限制和共享资源的问题。
因为GIL的存在，只有一个线程运行，那么为什么会出现多线程竞争的情况？
尽管GIL的存在使得同一时间只有一个线程可以执行Python字节码，但多线程竞争的问题仍然可能会出现。这是因为在Python中，多线程并发执行时，多个线程可以同时访问共享资源，如全局变量、文件、数据库等。当多个线程同时读写共享资源时，就可能出现数据不一致或竞争条件。
例如，假设有两个线程同时修改同一个全局变量，由于GIL的存在，只有一个线程可以执行，但两个线程都可以访问全局变量。如果两个线程都同时修改了全局变量的值，那么就可能导致数据不一致或竞争条件。
因此，尽管GIL限制了Python的多线程并发性能，但多线程竞争问题仍然需要程序员注意。为了避免多线程竞争问题，可以使用锁、线程安全的数据结构或者多进程等技术来保护共享资源，确保数据的一致性和正确性。

多线程的执行顺序？
随机。
在Python中，多线程的执行顺序是不确定的。这是因为线程调度是由操作系统来控制的，Python解释器无法控制线程的执行顺序。
当Python程序中有多个线程时，每个线程都会分配到一定的CPU时间片，并且由操作系统来调度执行。由于操作系统调度线程的时间片是不确定的，因此每个线程的执行顺序也是不确定的。
例如，假设有两个线程同时执行，线程A和线程B。线程A可能会执行一段时间，然后被操作系统挂起，然后线程B开始执行。当线程B执行一段时间后，操作系统可能会重新调度线程A执行。这种调度方式是由操作系统来控制的，Python解释器无法干预。
因此，在Python中编写多线程程序时，需要考虑到线程执行顺序的不确定性，并且需要使用一些同步机制来保证数据的一致性和正确性。例如，可以使用锁、条件变量、信号量等机制来控制多个线程对共享资源的访问。


什么是线程安全？什么是互斥锁？
线程安全是指当一个线程访问共享资源时，不会受到其他线程的干扰，保证了线程访问数据的完整性与正确性。 互斥锁的重点是互斥性，即一个线程获得这把锁后，其他线程都不能获取，只有释放这把锁后，其他线程才能获取。 如何保证线程安全？单线程下，从始至终都只有一个线程在运行，因此，线程是安全的；多线程下要保证线程安全需要使用互斥锁，线程不具有内存空间，同一进程下的所有线程共享进程的内存空间，为共享资源添加互斥锁后，确保同一时刻只有一个线程可以访问和操作共享资源，从而确保多线程下的线程安全问题。

多线程和多进程之间如何实现通信？
在Python中，多进程和多线程之间的通信可以通过多种方式实现。以下是一些常见的方法：

多进程通信：
1、管道（Pipe）：可以使用multiprocessing.Pipe()创建一个双向的通信通道，返回两个连接对象，分别代表管道的读端和写端。可以在一个进程中向管道写入数据，另一个进程从管道读取数据。
2、队列（Queue）：可以使用multiprocessing.Queue()创建一个先进先出的队列对象，用于在多个进程之间共享数据。进程可以通过调用put()方法向队列中添加数据，通过调用get()方法从队列中获取数据。
3、共享内存（Shared Memory）：可以使用multiprocessing.Value()或multiprocessing.Array()创建共享内存对象，以便多个进程可以访问和修改同一块内存区域。
4、锁（Lock）：当多个进程需要访问共享资源时，可以使用锁来确保同一时间只有一个进程可以访问共享资源。可以使用multiprocessing.Lock()创建一个锁对象，用于实现进程间的同步。
多线程通信：
1、锁（Lock）：与多进程类似，多线程也可以使用锁来确保同一时间只有一个线程可以访问共享资源。可以使用threading.Lock()创建一个锁对象。
2、条件变量（Condition Variable）：可以使用threading.Condition()创建一个条件变量对象，用于在线程之间同步和通信。条件变量可以让一个或多个线程等待某个条件成立，然后通知其他线程。
3、信号量（Semaphore）：可以使用threading.Semaphore()创建一个信号量对象，用于控制线程的并发数量。信号量可以用于限制同时访问共享资源的线程数量。
4、事件（Event）：可以使用threading.Event()创建一个事件对象，用于通知其他线程某个事件已经发生。事件可以用于协调多个线程的执行顺序。
需要注意的是，多进程和多线程之间的通信方式有所不同。多进程通信需要使用进程间通信（IPC）机制，如管道、队列和共享内存等。而多线程通信则通常使用线程间通信（ITC）机制，如锁、条件变量、信号量和事件等。


Python中创建线程的两种方法？
在Python中常用threading模块创建线程，threading模块创建线程时，可以采取两种方式，一种是通过继承threading.Thread类来创建，另一种是使用threading.Thread类来创建。
from threading import Thread

# 自定义线程类
class MyThread(Thread):
    # 初始化方法
    def __init__(self, name, id):
        Thread.__init__(self)  # 调用父类的初始化方法
        self.id = id
        self.name = name

    # 重构run()方法
    def run(self):
        print('{}是第{}个线程'.format(self.name, self.id))

t1 = MyThread('Thread1', 1)
t1.start()  # 启动线程
# 等待线程运行完毕
t1.join()
在这种方式中，我们创建了一个自定义的线程类MyThread，该类继承了Thread类。
我们在自定义的线程类中重写了run()方法，该方法在线程启动后自动执行。
最后，我们创建了一个MyThread类的实例，并调用start()方法启动线程，然后调用join()方法等待线程执行完毕。
使用threading.Thread类创建线程
python
复制代码
from threading import Thread
# 创建线程实例化对象
thread1 = Thread(target=执行函数, args=(参数1, 参数2))
# 运行线程
thread1.start()
# 等待线程运行完毕
thread1.join()
在这种方式中，我们直接使用Thread类创建了一个线程对象。
在创建线程对象时，我们需要传入一个可调用对象（通常是一个函数）作为target参数，该对象将在新的线程中执行。
此外，我们还可以传入一个元组作为args参数，该元组中的元素将作为参数传递给target。最后，我们调用start()方法启动线程，然后调用join()方法等待线程执行完毕。


简述Django框架中的ORM应用
Django框架中的ORM（对象关系映射）是一个强大的工具，可以让开发人员以面向对象的方式与数据库交互，而无需编写原生的SQL语句。这是Django的一个关键特性，使得开发人员可以更专注于应用程序的业务逻辑，而不是花费大量时间处理数据库查询和更新。
以下是Django ORM应用的一些主要特点：
1、数据库抽象：Django ORM可以自动将Python代码转换为SQL语句，使得开发人员无需关注不同数据库的SQL语法差异。这意味着你的代码可以在不同的数据库系统（如PostgreSQL、MySQL、SQLite等）之间轻松切换。
2、模型定义：在Django中，你可以通过定义模型（Model）来创建数据库表。模型是一个Python类，它的属性和方法定义了表的结构和行为。你可以通过定义模型的字段（Field）、元数据（Meta）等来定义表的结构，也可以通过定义模型的管理器（Manager）和方法来定义表的行为。
3、查询和过滤：Django ORM提供了一套丰富的查询和过滤API，你可以通过它们来检索数据库中的数据。例如，你可以使用filter()方法来过滤出满足特定条件的记录，使用order_by()方法来对结果进行排序，使用values()方法来获取特定字段的值，等等。
4、关系处理：Django ORM还支持处理复杂的数据库关系，如一对一（OneToOneField）、一对多（ForeignKey）、多对多（ManyToManyField）等。你可以通过在模型中定义这些关系来建立表与表之间的联系，Django ORM会自动处理这些关系的数据库操作。
5、事务处理：Django ORM还支持数据库事务处理。你可以通过transaction.atomic()装饰器或者上下文管理器来定义一个原子操作，这个操作要么全部成功，要么全部失败，不会处于某种中间状态。这可以确保你的数据库操作的一致性和完整性。

谈谈你对Django的认识？
①Django是社区目前使用最多的Python Web框架，它十分强大，封装了许多功能模块，能够满足大部分Web开发需求。
②Django以MVC为基础进行优化改进，是一种MTV结构。
③Django具备完善的管理后台，可通过一些配置快速开发一个管理后台。
④Django具备内置的ORM框架，可以很方便地进行数据库操作。但是内置的ORM框架同Django框架中的其他模块耦合度较高，使用其他ORM框架时不能享受到其他模块提供的便利。
⑤Django内置了许多功能模块，因此体积较大，小型项目不能充分发挥Django的特性与性能，不适合小型项目的个性化定制。
⑥Django框架推行样式文件与逻辑代码分离，因此，在模板文件中不会存在大量Python代码进行逻辑处理。

nginx是什么？有什么作用？
nginx是一种web服务器，可以用来作为代理服务器、负载均衡服务器和邮件代理服务器等。
nginx的功能有：
1、作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx 尤其受到虚拟主机提供商的欢迎。 能够支持高达 50,000 个并发连接数的响应.
2、作为负载均衡服务器：Nginx 既可以在内部直接支持 Rails 和 PHP，也可以支持作为 HTTP代理服务器 对外进行服务。
3、作为邮件代理服务器：Nginx 同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器）

Nginx的正向代理和反向代理分别是什么？
正向代理时nginx是客户端
Nginx的正向代理和反向代理是两种不同的代理模式，以下是它们的主要区别：
正向代理：在这种代理模式下，客户端无法直接访问目标服务器，而是通过一个代理服务器来访问。代理服务器会将客户端的请求转发给目标服务器，并将目标服务器返回的响应返回给客户端。正向代理通常用于以下场景：
突破网络限制：在某些网络环境下，访问特定网站或服务可能会被限制，而使用正向代理可以绕过这些限制，访问被限制的内容。
加速访问速度：在某些情况下，代理服务器可以缓存目标服务器返回的内容，以提高访问速度。
隐藏客户端IP地址：在某些情况下，客户端希望隐藏自己的IP地址，以保护自己的隐私。
反向代理时nginx是服务端
反向代理：在这种代理模式下，客户端访问的是代理服务器，而代理服务器则将请求转发给目标服务器。目标服务器返回的响应也会经过代理服务器，最终返回给客户端。反向代理通常用于以下场景：
负载均衡：在高并发的情况下，使用反向代理可以将请求分发到多个目标服务器上，以提高系统的并发能力。
提高安全性：反向代理可以隐藏目标服务器的真实IP地址，以防止攻击者直接攻击目标服务器。
简化架构：使用反向代理可以将多个服务部署在不同的服务器上，但对外提供统一的入口，以简化架构。


Django的请求生命周期？
①用户在浏览器中输入要访问网页的网址，浏览器会生成相应的request请求，request请求分为请求头和请求体两部分，请求会以“GET”“POST”方式提交到服务器。
②请求提交到服务器后，会先经过Django的中间件进行处理，符合中间件标准的请求会传递到URL路由映射列表。
③在URL路由映射列表中从前到后逐条匹配，直到匹配成功，将请求提交给对应的视图函数。
④在视图函数中，根据请求的提交方式进行相应处理，处理完成后将处理结果进行返回。
⑤返回结果通过中间处理返回给浏览器。
⑥浏览器接收返回信息，进行解析、渲染，显示给用户。

Django的MTV框架模式指的的什么？
MTV即模型（Model）、模板（Template）、视图（Views），三者之间各自负责不同的指责。

模型：数据存取层，处理与数据相关的所有事务，例如如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。
模板：表现层，处理与表现相关的决定，例如如何在页面或其他类型的文档中进行显示。
视图：业务逻辑层，存取模型及调取恰当模板的相关逻辑，模型与模板的桥梁。

简述什么是FBV和CBV？
FBV和CBV本质是一样的
基于函数的视图叫做FBV，基于类的视图叫做CBV
在python中使用CBV的优点：
(1.提高了代码的复用性，可以使用面向对象的技术，比如Mixin（多继承）
(2.可以用不同的函数针对不同的HTTP方法处理，而不是通过很多if判断，提高代码可读性

简述MVC和MTV
MVC软件系统分为三个基本部分：模型(Model)、视图(View)和控制器(Controller)

Model：负责业务对象与数据库的映射(ORM)
View：负责与用户的交互
Control：接受用户的输入调用模型和视图完成用户的请求

Django框架的MTV设计模式借鉴了MVC框架的思想,三部分为：Model、Template和View
Model(模型)：负责业务对象与数据库的对象(ORM)
Template(模版)：负责如何把页面展示给用户
View(视图)：负责业务逻辑，并在适当的时候调用Model和Template

简述Django中的CSRF的实现原理
在用户访问网站时，Django在网页表单中生成一个隐藏控件csrfmiddlewaretoken，控件属性value的值时由Django随机生成的。
当用户提交表单时，Django校验表单的csrfmiddlewaretoken是否与自己保存的csrfmiddlewaretoken一致，用来判断当前请求是否合法。
如果用户被CSRF攻击并从其他地方发送📴请求，由于其他地方不可能知道隐藏控件csrfmiddlewaretoken的值，因此导致网站后台校验csrfmiddlewaretoken失败，攻击就被成功防御。



Web 知识
Cookie和Session应用场景及案例
HTTP协议本身是”无状态”的，在一次请求和下一次请求之间没有任何状态保持，服务器无法识别来自同一用户的连续请求。有了cookie和session，
服务器就可以利用它们记录客户端的访问状态了，这样用户就不用在每次访问不同页面都需要登录了。
cookie是一种数据存储技术, 它是将一段文本保存在客户端(浏览器或本地电脑)的一种技术，并且可以长时间的保存。当用户首次通过客户端访问服务器时，web服务器会发送给客户端的一小段信息。
客户端浏览器会将这段信息以cookie形式保存在本地某个目录下的文件内。当客户端下次再发送请求时会自动将cookie也发送到服务器端，这样服务器端通过查验cookie内容就知道该客户端之前访问过了。
cookie的常见应用场景包括:
判断用户是否已经登录
记录用户登录信息(比如用户名，上次登录时间）
记录用户搜索关键词
cookie的缺点在于其并不可靠和不安全，主要原因如下:
浏览器不一定会保存服务器发来的cookie，用户可以通过设置选择是否禁用cookie。
cookie是有生命周期的（通过Expire设置），如果超过周期，cookie就会被清除。
HTTP数据通过明文发送，容易受到攻击，因此不能在cookie中存放敏感信息（比如信用卡号，密码等）。
cookie以文件形式存储在客户端，用户可以随意修改的。

什么是session及session的工作原理
session又名会话，其功能与应用场景与cookie类似，用来存储少量的数据或信息。但由于数据存储在服务器上，而不是客户端上，
所以比cookie更安全。不过当用户量非常大时，所有的会话信息都存储于服务器会对服务器造成一定的压力。
前后端分离时为何推荐token认证？
Token无需存储降低服务器成本，session是将用户信息存储在服务器中的，当用户量增大时服务器的压力也会随着增大。
防御CSRF跨站伪造请求攻击，session是基于cookie进行用户识别的, cookie如果被截获，用户信息就容易泄露。
扩展性强，session需要存储无法共享，当搭建了多个服务器时其他服务器无法获取到session中的验证数据用户无法验证成功。Token可以实现服务器间共享，这样不管哪里都可以访问到。
Token可以减轻服务器的压力，减少频繁的查询数据库。
支持跨域访问, 适用于移动平台应用

序列化
序列化是指将对象的状态信息转换为可以存储或传输形式的过程，在客户端与服务端传输的数据形式主要分为两种：XML和JSON。
在Django中的序列化就是指将对象状态的信息转换为JSON数据，以达到将数据信息传送给前端的目的。


域名
顶级域名、一级域名、二级域名
.com 顶级域名/一级域名，更准确的说叫顶级域
baidu.com 二级域名，更准确的说叫二级域
tieba.baidu.com 三级域名，更准确的说叫三级域
detail.tieba.baidu.com 四级域名，更准确的说叫四级域

子域名
子域名是在域名系统等级中，属于更高一层域的域。比如，mail.example.com 和 calendar.example.com是example.com的两个子域，而example.com则是顶级域.com的子域

同源策略
浏览器有同源策略，如果两个url的协议、域名、端口完全一致才是同源，有一个不一致就是跨域
子域名也算跨域

同源策略限制
1.DOM：禁止操作非源页面的DOM与JS对象
这里主要场景是iframe跨域的情况，非同源的iframe是限制互相访问的
2.XmlHttpRequest：禁止使用XHR对象向不同源的服务器发起HTTP请求，即不能发送跨域ajax请求
主要用来防止CSRF攻击
3.本地存储：Cookie、LocalStorage和IndexDB无法跨域读取

跨域(cross-origin)
违反同源策略就是跨域

跨站(cross-site)
只有两个URL的eTLD+1相同即是同站（Same Site），不需要考虑协议和端口
eTLD：有效顶级域名/一级域名，如.com、.co.uk、.github.io、.top等
eTLD+1：有效顶级域名+二级域名，如 taobao.com,baidu.com
顶级域名和二级域名相同即为同站
跨站一定跨域，跨域未必跨站

如何检查请求是否为 同站、同源、跨站
Chrome发送请求时会附带一个Sec-Fetch-Site HTTP Header ，Sec-Fetch-Site表示一个请求发起者的来源与目标资源来源之间的关系，这个Header将有以下值之一
cross-site 跨站/跨域
same-site 同站
same-origin 同源
none
通过检查Sec-Fetch-Site的值，可以确定请求是同站、同源还是跨站


Cookie特点
-保存在用户的浏览器中
-可以主动清除
-可以被伪造
-不可以跨站共享Cookie

Session机制
Session机制与Cookie机制类似，再服务器端st-cookie同时，返回给用户一个Session_id，之后用户每次数据请求都带上Session_id,服务器端根据Session_id来
创建和更新Session表中的数据，并返回给用户特定的数据。
session比cookie更安全，因为session机制将用户的登录信息存在服务器端，而不是浏览器。
session更适合存储用户的状态信息，比如用户的搜索记录，用户观看视频的进度等

Cookie和Session的局限性
1.Cookie和Session都将数据存储于浏览器的Cookie中，如果在没有浏览器的智能硬件上完成登录，就无法实现登录功能
2.由于同源策略的局限性，Cookie不能跨站

Token机制
从各个终端与服务器端进行数据交互的身份验证的字符串，就是Token。Token被翻译为"令牌"
Token的身份验证流程
1.浏览器携带账号密码进行请求服务器
2.服务器返回token
3.浏览器请求api时携带token
4.返回数据


JWT(Json Web Token)的原理
JWT的生命周期分为以下5步
1.用户在前端进行账号和密码进行登录操作，将身份信息发送到后端服务器进行身份验证
2.如果后端服务器通过了身份验证，则会将一部分身份信息通过非对称加密生成JWT，返回给前端
3.前端获取到JWT之后，将JWT保存到本地
4.从前端向后端发送数据请求，都携带JWT
5.后端验证JWT，如果通过验证，就返回请求的数据；如果没通过，则返回错误提示。
JWT的数据结构是很长的一段字符串，分为头部，负载和签名
虽然JWT会因为字符串很长而导致自动折行，但是JWT本身就一行


RESTful规范
(1) 如果是对同一个表进行数据操作（增删查改)，应该使用一条API，然后根据method的不同，进行不同的操作
GET/POST/PUT/DELETE/PATCH
(2) 面向资源编程，通过API提交的参数最好是名词，比如name，尽量少用动词
www.abc.com/name
(3) 体现版本，在API中加入像v1、v2这样的版本代号
www.abc.com/v1/name
www.abc.com/v2/name
(4) 体现API，让使用者能一眼看出这是API而不是URL，应该在API中加入提示：
www.abc.com/api/v1/name
www.abc.com/api/v2/name
(5) 使用HTTPS，这一项是为了安全考虑
(6) 响应式设置状态码，例如200和201表示操作成功，403表示权限不够
(7) API的参数中加入筛选条件参数，也可以理解为获取资源优先选择GET的方式
www.abc.com/api/v2/name?page=1&size=10
(8) 返回值的规范，不同的method操作成功后，后端应该响应的返回值如下“
不同的提交方式代表对数据进行不同的操作：
www.abc.com/api/v1/name
GET：所有列表
POST：新增数据
www.abc.com/api/v1/name/1
GET:单条数据
PUT：更新
PATCHH:局部更新，返回更新的数据
DELETE：删除，返回空文档
(9) 返回错误信息，应该加入错误代号code，让用户能直接看出是哪种类型的错误
(10) 返回的详细信息，应该以字典的形式放在data中

HTTP和HTTPS区别
1.HTTP是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS则解决HTTP不安全的缺陷，在TCP和HTTP网络层之间加入了SSL/TLS安全协议，使报文能加密传输
2.HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输
3.HTTP 的端口号是 80，HTTPS 的端口号是 443
4.HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的

HTTP 由于是明文传输，所以安全上存在以下三个风险：
窃听风险，比如通信链路上可以获取通信内容，用户号容易没。
篡改风险，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。
冒充风险，比如冒充淘宝网站，用户钱容易没。

HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议，可以很好的解决了上述的风险：
信息加密：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。
校验机制：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。
身份证书：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。

WSGI和ASGI
WSGI
Web服务器网关接口（Python Web Server Gateway Interface），缩写为WSGI，它是一种专为python定义的接口规范，用于web服务端和web应用（框架）之间的连接，
如此web应用可以一起处理一个请求，同时也是基于CGI进行设计的
ASGI
异步网关接口（Asynchronous Server Gateway Interface），是WSGI的扩展版本，旨在为Python Web服务、框架和应用之间提供一个标准的异步接口。
其本身可以提供同步和异步应用，并且可以并行处理。还能处理多种通用协议，包括HTTP，HTTP2和WebSocket。同WSGI一样，需要有独立的服务器实现这种异步的网关接口，比如Daphne、Uvicorn、Hypercorn等

什么是asgi.py？
ASGI（Asynchronous Server Gateway Interface）是一种 Python 异步 Web 服务器和应用程序之间通信的接口标准。Django ASGI 是 Django 框架的 ASGI 版本，它允许 Django 应用程序以异步方式处理
请求和响应。与传统的 WSGI（Web Server Gateway Interface）相比，ASGI 更适用于高并发和实时性要求高的应用程序，例如聊天应用、实时通知、在线游戏等。
以下是 Django ASGI 的主要作用：
1. **支持异步请求处理**：ASGI 允许 Django 应用程序处理异步请求。这意味着应用程序可以同时处理多个请求，而不必等待一个请求处理完成后才处理下一个请求。这对于需要高并发性能的应用程序非常有用。
2. **实时通信和 WebSocket 支持**：ASGI 支持实时通信和 WebSocket 连接，使 Django 应用程序能够实时推送数据给客户端，而不必等待客户端发起请求。这对于构建实时聊天应用、在线游戏和实时通知系统非常重要。
3. **长轮询（Long Polling）支持**：ASGI 允许应用程序使用长轮询技术，以实现客户端与服务器之间的实时通信。这对于应对一些不支持 WebSocket 的网络环境是有用的。
4. **并发性能提升**：ASGI 支持异步框架和库，这些库可以充分利用服务器的多核心处理器，提高应用程序的并发性能。
5. **第三方中间件和组件**：ASGI 允许开发人员使用第三方中间件和组件来扩展 Django 应用程序的功能，以满足特定需求。这些中间件和组件可以处理异步任务、实现缓存、加速数据库访问等。
6. **更灵活的部署选项**：ASGI 支持多种异步 Web 服务器，例如 Daphne、Uvicorn 和 Hypercorn，这些服务器可以用于部署 Django ASGI 应用程序。这为部署和扩展提供了更多选择。

什么是wsgi.py？
WSGI（Web Server Gateway Interface）是一种 Python Web 应用程序和 Web 服务器之间的标准接口。Django WSGI 是指 Django 框架与 WSGI 标准的集成，
1. **与 Web 服务器的通信**：WSGI 充当了 Django 应用程序与 Web 服务器之间的中间层，负责处理 HTTP 请求和响应。它允许 Django 应用程序与各种符合 WSGI 标准的 Web
服务器（如 Apache、Nginx、Gunicorn、uWSGI 等）进行通信。
2. **处理请求**：WSGI 接受来自 Web 服务器的 HTTP 请求，并将这些请求传递给 Django 应用程序的入口点。在 Django 中，入口点通常是一个名为 `wsgi.py` 的文件，
它初始化 Django 项目并将请求传递给 Django 框架进行处理。
3. **处理响应**：一旦 Django 框架处理完请求，它将生成一个 HTTP 响应，并将其传递回 WSGI 层，然后由 Web 服务器发送给客户端。这使得 Django
应用程序能够生成并返回动态的 HTML 内容，以响应客户端的请求。
4. **多进程/多线程支持**：WSGI 允许多个并发请求同时处理，这有助于提高应用程序的性能。各种 WSGI 服务器可以配置为使用多进程或多线程来处理请求，以适应不同的负载和性能需求。
5. **可扩展性**：通过使用 WSGI 兼容的 Web 服务器，你可以轻松地部署 Django 应用程序，而无需修改应用程序的代码。这使得应用程序能够在不同的环境和服务器上运行，以满足不同的部署需求。
6. **中间件**：Django WSGI 允许你使用中间件来自定义请求和响应的处理过程。中间件是一种用于在请求和响应处理流程中执行额外逻辑的机制，例如身份验证、日志记录、缓存等。
允许 Django 应用程序在标准的 WSGI 兼容 Web 服务器上运行。以下是 Django WSGI 的主要作用：

asgi VS wsgi 区别
ASGI（Asynchronous Server Gateway Interface）和 WSGI（Web Server Gateway Interface）都是 Python Web 应用程序与 Web 服务器之间的接口标准，但它们有一些重要的区别：
1. **同步 vs. 异步**：
- WSGI 是一个同步接口，这意味着它是基于同步 I/O 的。在 WSGI 应用程序中，每个请求都是按顺序处理的，一个请求需要等待另一个请求完成后才能继续。这对于低并发的应用程序是足够的，
但在高并发场景下可能会限制性能。
- ASGI 是一个异步接口，支持异步 I/O。ASGI 应用程序可以处理多个请求，而无需等待一个请求完成。这使得 ASGI 更适合于高并发和实时性要求高的应用程序，例如聊天应用、实时通知、在线游戏等。
2. **WebSocket 和长轮询支持**：
- ASGI 支持 WebSocket 连接和长轮询（Long Polling），使得实时通信更容易实现。
- WSGI 不直接支持 WebSocket，虽然可以通过扩展和库来实现，但相对复杂。
3. **性能差异**：
- 由于异步处理的能力，ASGI 可以更好地处理高并发情况，因此在某些场景下性能可能更好。
- WSGI 在处理低并发和传统 Web 应用程序时表现良好，但在高并发场景下可能会有限制。
4. **中间件和组件**：
- ASGI 和 WSGI 都支持中间件和组件，但由于异步性质的不同，ASGI 中的中间件可能需要以异步方式编写。
- WSGI 中的中间件通常是同步的。
5. **部署选项**：
- WSGI 应用程序可以在广泛的 Web 服务器上运行，因为许多 Web 服务器都支持 WSGI 接口。
- ASGI 应用程序通常需要专门支持 ASGI 标准的服务器，例如 Daphne、Uvicorn、Hypercorn 等。
总的来说，ASGI 更适合处理高并发、实时通信和异步任务处理等需求，而 WSGI 更适合传统的 Web 应用程序。在选择 ASGI 还是 WSGI 时，需要根据你的应用程序的性质和性能需求来做出决策。
如果你的应用程序需要实时通信、WebSocket 支持或需要处理大量并发请求，那么考虑使用 ASGI 可能是一个明智的选择。否则，WSGI 可能足够满足你的需求。
HTTP协议与TCP协议的区别
1.TCP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。
TCP/IP和HTTP协议的关系，从本质上来说，二者没有可比性，我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，
便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET 等，也可以自己定义应用层协议。
WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。

2.Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，
当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的，所以Http连接是一种短连接，是一种无状态的连接。
所谓的无状态，是指浏览器每次向服务器发起请求的时候，不是通过一个连接，而是每次都建立一个新的连接。如果是一个连接的话，服务器进程中就能保持住这个连接并且在内存中记住一些信息状态。
http/https是一种无状态协议，客户端和服务器交互后再没有联系。我们输入账户密码访问网页时，再访问网站的其他网页，会通过客户端向服务器发送了不止一次数据请求。为什么网站服务器没有
要求我们再输入一次用户名和密码，这是因为Cookie的存在。
Cookie工作原理
1.用户通过客户端输入用户名和密码后，登录网站
2.网站服务器返回登录成功信息的同时，在协议头返回用户的用户名和密码等信息，这些信息被保存在浏览器的缓存中，这一步叫做set-Cookie
3.当完成登录操作的用户访问网站的其他网页时，每一次从客户端浏览器发送给服务器的数据请求，协议头都会带上之前的Cookie键值对，服务器通过对
这些键值对判断用户是否是登录状态，并返回已经登录的用户才能访问的数据。

WSGI 、uWSGI、uwsgi和Nginx
WSGI（Web Server Gateway Interface）:WSGI 是一个 Python Web 应用程序与 Web 服务器之间的接口规范，
它定义了应用程序和服务器之间的标准接口，使得应用程序可以在不同的 Web 服务器上运行。WSGI 规范规定了
应用程序必须实现的接口方法和服务器需要支持的方法。WSGI 协议使得不同的 Python Web 框架（例如 Flask、
Django 等）能够在不同的 Web 服务器上运行，这些服务器可以是 Apache、Nginx 等。
uWSGI：uWSGI 是一个 Web 服务器，它是一个用 C 语言编写的 Web 应用程序容器，支持运行 Python、Ruby、
Perl 等多种编程语言。uWSGI 服务器可以作为一个独立的应用服务器，也可以与其他 Web 服务器（如 Nginx、
Apache）一起使用，通过 WSGI 协议与 Python 应用程序通信。
uwsgi：uwsgi 是一个与 uWSGI 服务器相关的协议。uwsgi 协议是一种二进制协议，它定义了 uWSGI 服务器与
应用程序之间的通信协议。使用 uwsgi 协议，uWSGI 服务器可以与 Python 应用程序通信，而不需要像 CGI 那
样启动一个新的进程来处理每个请求。uwsgi 协议允许 uWSGI 服务器与应用程序之间进行双向通信，从而提高了性能。
Nginx：Nginx是一个Web服务器其中的HTTP服务器功能和uWSGI功能很类似，但是Nginx还可以用作更多用途，
比如最常用的反向代理功能和缓存静态资源，加快访问速度。
用户——>web服务器——>web应用程序
浏览器—HTTP—>Nginx—uwsgi—>uWSGI—uwsgi—>web应用(Django等)
uwsgi是WSGI的一种实现

Socket
socket的英文原义是“孔”或“插座”。作为进程通信机制，取后一种意思。通常也称作“套接字”，用于描述IP地址和端口，是一个通信链的句柄。(其实就是两个程序通信用的。)socket非常类似于电话的插座。以一个电话网为例。
电话的通话双方相当于相互通信的2个程序，电话号码可以当作是IP地址。任何用户在通话之前，首先要占有一部电话机，相当于申请一个socket；同时要知道对方的号码（IP地址），
相当于对方有一个固定的socket。然后向对方拨号呼叫，相当于发出连接请求。对方假如在场并空闲，拿起电话话筒，双方就可以正式通话，相当于连接成功。双方通话的过程，是一方向电话机发出信号和对方从电话机接收信号的过程，
相当于向socket发送数据和从socket接收数据。通话结束后，一方挂起电话机相当于关闭socket，撤消连接，通信完成。
以上通信是以两个人通话做为事例来在概的说明了下通信，但是现在假如通信中的一个人是外国人（说英语），一个人是中国人（说普通话），他们俩相互通信的话，都不能听明白对方说的是什么，那么他们的沟通就不能够完成。
但是如果我们给一个规定，给通话双方，只能讲普通话，那么双方沟通就没有障碍了。这就引出来了通信协议。
有两种类型：（Tcp协议与Udp协议）:
Tcp协议与Udp协议是在两硬件设备上进行通信传输的一种数据语法。
– 流式Socket（STREAM）：
    是一种面向连接的Socket，针对于面向连接的TCP服务应用，安全，但是效率低；Tcp:是以流的形式来传的。
– 数据报式Socket（DATAGRAM）：
    是一种无连接的Socket,对应于无连接的UDP服务应用.不安全(丢失,顺序混乱,在接收端要分析重排及要求重发),但效率高.Udp:将数据包拆开为若干份编号后来传输。在传输的过程中容易出现数据的丢失。但是传输速度要比TCP的快。

粘包与拆包
TCP在接受数据的时候，有一个滑动窗口来控制接受数据的大小，这个滑动窗口你就可以理解为一个缓冲区的大小。缓冲区满了就会把数据发送。数据包的大小是不固定的，有时候比缓冲区大有时候小。
如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题；
如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包，也就是将一个大的包拆分为多个小包进行发送。
粘包：多个数据包合并在一个缓冲区
拆包：一个数据包多次发送，分散在不同的缓冲区

为什么TCP协议出现粘包和拆包问题？
TCP在接受数据的时候，有一个滑动窗口来控制接受数据的大小，这个滑动窗口你就可以理解为一个缓冲区的大小。缓冲区满了就会把数据发送。数据包的大小是不固定的，有时候比缓冲区大有时候小。
如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题；
如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包，也就是将一个大的包拆分为多个小包进行发送。

UDP不会发生粘包问题
UDP具有保护消息边界,在每个UDP包中就有了消息头(UDP长度、源端口、目的端口、校验和)。
粘包拆包问题在数据链路层、网络层以及传输层都有可能发生。日常的网络应用开发大都在传输层进行，由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中

解决粘包和拆包的常见四种解决方案
对于粘包和拆包问题，常见的解决方案有四种：

1、客户端在发送数据包的时候，每个包都固定长度，比如1024个字节大小，如果客户端发送的数据长度不足1024个字节，则通过补充空格的方式补全到指定长度；
2、客户端在每个包的末尾使用固定的分隔符，例如\r\n，如果一个包被拆分了，则等待下一个包发送过来之后找到其中的\r\n，然后对其拆分后的头部部分与前一个包的剩余部分进行合并，
这样就得到了一个完整的包；
3、将消息分为头部和消息体，在头部中保存有当前整个消息的长度，只有在读取到足够长度的消息之后才算是读到了一个完整的消息；
4、通过自定义协议进行粘包和拆包的处理。

Python语法糖或高级用法
1、列表推导式
2、三目运算
print("True") if a>5 else print(False)
3、匿名函数
li = [1,2,3,4,5]
filter(lambda x: x>10, li)
4、交换值
a ,b= b,a
5、函数参数可设默认值
6、函数参数数量可变，*args：元组，**kwargs：可变键值对
7、函数传参可传函数
8、类型标注，函数参数类型标注，函数返回值类型标注
def greeting(name: str) -> str:
    return 'Hello ' + name
9、函数体用三引号注释，首行简述函数功能， 第二行空行， 第三行为函数的具体描述
rest风格
This is a reST style.
:param param1: this is a first param
:param param2: this is a second param
:returns: this is a description of what is returned
:raises keyError: raises an exception

#########################################################################################################
PEP8编码规范
空格空行使用
1、使用空格表示缩进，不要用制表符
2、和语法相关的每一层缩进都用4个空格表示
3、每行不超过79个字符，除了首行其余各行都在正常的缩进程度上再加上4个空格
4、函数和类的定义，代码前后都要用两个空行进行分隔
5、在同一个类中，各个方法之间应该用一个空行进行分隔
6、二元运算符左右两侧应该保留一个空格
标识符命名
1、变量、函数和属性应该使用小写字母来拼写，如果有多个单词就使用下划线进行连接
2、类中受保护的实例属性，应该以一个下划线开头
3、类中私有的实例属性，应该以两个下划线开头
4、类和异常的命名，应该每个单词首字母大写
5、模块级别的常量，应该采用全大写字母，如果有多个单词就用下划线进行连接
6、类的实例方法，应该把第一个参数命名为self以表示对象自身
7、类的类方法，应该把第一个参数命名为cls以表示该类自身
表达式和语句
1、采用内联形式的否定词，而不要把否定词放在整个表达式的前面。例如if a is not b就比if not a is b更容易让人理解
2、不要用检查长度的方式来判断字符串、列表等是否为None或者没有元素，应该用if not x这样的写法来检查它
3、就算if分支、for循环、except异常捕获等中只有一行代码，也不要将代码和if、for、except等写在一起，分开写才会让代码更清晰
4、import语句总是放在文件开头的地方
5、引入模块的时候，from math import sqrt比import math更好
6、如果有多个import语句，应该将其分为三部分，从上到下分别是Python标准模块、第三方模块和自定义模块，每个部分内部应该按照模块名称的字母表顺序来排列



Python知识查漏补缺
变量、对象、赋值、引用、拷贝
变量
1、第一次赋值时，即创建，之后再次赋值将会改变变量的值
2、变量名本身是没有类型的，类型只存在对象中，变量只是引用了对象
3、所有的变量，在使用前必须赋值，使用未赋值的变量会产生错误

对象
1、对象是有类型的
2、对象是分配的一块内存空间，来表示它的值
3、每一个对象都具有两个标准的头部信息：
类型标识符：标识对象的类型
引用计数器：用来决定对象是不是进行回收
对象三要素：id,type,value
id:唯一标识一个对象
type:标识对象的类型
value:对象的值

引用
1、在Python中，从变量到对象的连接，称为引用
2、引用是一种关系，在内存中以指针的的形式实现
3、赋值操作时，自动建立变量和对象之间的关系，即引用

赋值和引用
python中赋值语句，总是建立对象的引用值，而不是复制对象
因此，python变量更像是指针，而不是数据存储区域

简单引用
a = 3
创建一个对象来表示3
创建一个变量a，如果他还没有被创建的话
将变量a与新的对象3相连
a=1
a='python'
a=1.2
这里的变量a被多次赋值
并不是修改的对象，而是修改的引用
a指向1，然后修改引用指向 'python'
最后指向1.2
1 和 'python' 被放在内存空间内
在没有其他变量引用时，引用计数为0
这个对象的内存空间就会自动回收
这里也并不是修改变量 a 的类型
因为变量没有类型，只是它指向的对象具有类型
即对象头部信息的类型标志符

共享引用
a = 3
b = a
a指向对象3
b = a 赋值操作
b也指向3
可以看出，a和b都引用了同一个对象
a = 3
b = a
a = 'spam'
a指向spam，b仍然指向3

对象的数据类型：列表list
lst1 = [1, 2, 3]
lst2 = lst1
lst3 = [1, 2, 3]
print(lst1,id(lst1)) #[1, 2, 3] 4434387024
print(lst2,id(lst2)) #[1, 2, 3] 4434387024
print(lst3,id(lst3)) #[1, 2, 3] 4478611696
value相同，id不同

对象的数据类型：整数int
a = 9
b = a
c = 9
print(a,id(a))# 9 4393189392
print(b,id(b))# 9 4393189392
print(c,id(c))# 9 4393189392
a,b,c都指向同一个对象
因为小的整数和字符串被缓存并复用
所以is指明a和c，引用一个相同的对象

变量仅仅用来保存一个对象的地址
对象是分配的一块内存空间，有足够的空间去表示它们所代表的值
引用是自动形成的从变量到对象的指针

赋值，浅拷贝，深拷贝
可以说 Python 没有赋值，只有引用
Python 没有「变量」，我们平时所说的变量其实只是「标签」，是引用


a = [0, [1, 2], 3]
b = a[:]
a[0] = 8
a[1][1] = 9
b的第二个元素也会被改变，因为a[1]和b[1]都指向同一个对象[1,2]

引用VS拷贝
对于不可变对象和可变对象来说
浅复制都是复制的引用
只是因为复制不变对象和复制不变对象的引用是等效的
因为对象不可变，当改变时，会新建对象重新赋值
看起来浅复制只复制不可变对象（整数，实数，字符串等）
对于可变对象，浅复制其实是创建了一个对于该对象的引用
也就是说只是给同一个对象贴上了另一个标签而已

可变对象和不可变对象
Python的对象分成两类：可变对象和不可变对象。
可变对象是指，对象的内容是可变的，一般是指引用类型。
不可变的对象，表示其内容不可变。对于tuple中的可变对象也是可以改变的。
可变对象 ：list, dict, set
不可变对象 ：int, float, complex(复数类型), str,bool, tuple, frozenset(不可变集合)
Python中的赋值语句
不会创建对象的拷贝，仅是将名称绑定至一个对象,对于不可变对象，通常没什么差别
但处理可变对象或可变对象的集合时
可能需要创建这些对象的 “真实拷贝”
在修改创建的拷贝时，不改变原始的对象

python 函数参数中**用法
收集参数，拆解字典中的value，传给函数
################################################

itertools.product(*iterables, repeat=1)
等价于嵌套for循环，用于求多个可迭代对象的笛卡尔积


协程
协程, 可以理解为一种在线程里跑的子线程, 它的默认栈空间很小，当多个协程在一个线程上运行时,
协程间会切换着运行, 协程的切换完全在用户态完成, 而且时机由程序员来自行调度, 从而使得线程的并发量大大提升

async关键字定义的函数就是异步函数,
异步函数的实例化对象就是一个future
# 普通函数定义
def add1(x):
    print(x+1)
    return x+1

# 异步函数的定义
async def add2(x):
    print("in async fun add")
    return x+2

async关键字定义的函数就是异步函数,异步函数的实例化对象就是一个future
# add2(1)就是一个future
future = add2(1)  # 一个future对象就是一个协程
注意: 我这里说的是 异步函数的实例化对象 就是一个协程, 你可能会理解为异步函数的调用, 但我认为不合理, 因为这个协程并不会因为这个"调用"而开始执行.
在实例化后,这个协程的状态是pending, 即将要发生的

如何切换异步函数？
await后面必须跟一个协程(future), 就可以阻塞当前协程, 切换到这个新协程里执行
你可以把await认为是启动协程的一种方式, 和普通函数调用的效果相同






微服务
微服务就是采用容器技术的面向服务架构。它依然使用"服务"作为功能单元，但是变成了轻量级实现，不需要新增服务器，
只需要新建容器（一个进程），所以才叫做"微服务"



CPU不等于内存
不妨把外存比作一个大仓库，里面有各种原材料，可以生产不同的东西。而CPU就是进行加工处理的车间。
一般来说，一个时间段，想要生产的东西也就那几样（是确定的，也是有限的，毕竟CPU也是有限的）。
产品确定了，原材料自然也是确定的。而当我们去取原材料，因为外存这个大仓库实在是大，且里面放的是所有的原材料。直接从这里取太过耗时。
所以我们把一个时间段要用到的原材料都放到了一个距离更近的小仓库，也就是内存。生产所需的材料直接从这取好了，大大缩短IO时间。

阻塞
阻塞是一种被动行为，是在请求IO资源时，发生的等待。 IO资源拿到后，自动加入就绪任务队列，等待分配CPU。
因为拿不到IO资源，所以阻塞时会放弃 CPU的占用。
比如wait()，释放锁，释放CPU，等待。

分布式是什么？
分布式系统一定是由多个节点组成的系统。
其中，节点指的是计算机服务器，而且这些节点一般不是孤立的，而是互通的。
这些连通的节点上部署了我们的节点，并且相互的操作会有协同。
分布式系统对于用户而言，他们面对的就是一个服务器，提供用户需要的服务而已，
而实际上这些服务是通过背后的众多服务器组成的一个分布式系统，因此分布式系统看起来像是一个超级计算机一样。

线程池
系统启动一个新线程的成本是比较高的，因为它涉及与操作系统的交互。在这种情形下，使用线程池可以很好地提升性能，尤其是当程序中需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。
线程池在系统启动时即创建大量空闲的线程，程序只要将一个函数提交给线程池，线程池就会启动一个空闲的线程来执行它。当该函数执行结束后，该线程并不会死亡，而是再次返回到线程池中变成空闲状态，等待执行下一个函数。
此外，使用线程池可以有效地控制系统中并发线程的数量。当系统中包含有大量的并发线程时，会导致系统性能急剧下降，甚至导致 Python 解释器崩溃，而线程池的最大线程数参数可以控制系统中并发线程的数量不超过此数。






迭代器，生成器，可迭代对象？
迭代器：在python中，内部含有'iter'方法和'next'方法的对象就是迭代器。本质上for循环就是不断地调用迭代器的next方法
迭代器优点：1.提供了一种不依赖索引的迭代取值方式，2.节省内存：迭代器在内存中相当于只占一个数据的空间，因为每次取值，上一条数据会在内存释放
迭代器缺点：1.因为有next方法，只能往后取值，不能往前，取值不如索引方式灵活，不能取指定的某一个值，2.无法预测迭代器的长度
生成器：使用yield的函数叫生成器函数，函数被调用时会返回一个生成器对象，生成器本质上还是一个迭代器。yield对应的值在函数被调用时不会立刻返回，而是调用next方法时才返回。

可迭代对象：如果一个对象实现了__iter__方法，那么这个对象就是可迭代对象

可迭代对象包括迭代器序列字典，迭代器又包含生成器

什么是线程、进程、协程？有什么区别？
进程：是CPU对程序的一次执行过程。每个进程都是独立的，有自己的内存空间，一个进程可以有多个线程
线程：线程是包含在进程之中，是程序调度执行的基本单位。一个进程中的多个线程共享内存
协程：协程比线程更小，调度完全由用户控制。一个线程可以有很多线程
协程：通过async声明，await 表示在这个地方等待子函数执行完成，再往下执行。await 只能在带有 async 关键字的函数中运行
异步函数的实例化对象就是一个协程对象

celery是什么？
restful风格是什么？
restful风格：
1.用不同的http动词操作资源，GET：获取，PUT：更新，POST：新建，DELETE：删除
2.序列化和反序列化，序列化：python对象转为JSON，反序列化：json字节流转为Python对象

cookie和session？
cookie:
1.cookie一段文本，保存在客户端当用户首次通过客户端访问服务器时，web服务器会发送给客户端的一小段信息。
客户端浏览器会将这段信息以cookie形式保存在本地某个目录下的文件内。当客户端下次再发送请求时会自动将cookie也发送到服务器端，这样服务器端通过查验cookie内容就知道该客户端之前访问过了。
cookie有一些缺点：
浏览器不一定会保存服务器发来的cookie，用户可以通过设置选择是否禁用cookie。
cookie是有生命周期的（通过Expire设置），如果超过周期，cookie就会被清除。

-保存在用户的浏览器中
-可以主动清除
-可以被伪造
-不可以跨站共享Cookie

session:
1.session功能与应用场景与cookie类似，用来存储少量的数据或信息。但由于数据存储在服务器上，而不是客户端上，
所以比cookie更安全。不过当用户量非常大时，所有的会话信息都存储于服务器会对服务器造成一定的压力。在服务器端st-cookie同时，返回给用户一个Session_id，之后用户每次数据请求都带上Session_id,服务器端根据Session_id来
创建和更新Session表中的数据，并返回给用户特定的数据。

WSGI 、uWSGI、uwsgi和Nginx
WSGI（Web Server Gateway Interface）:WSGI 是一个 Python Web 应用程序与 Web 服务器之间的接口规范，
它定义了应用程序和服务器之间的标准接口，使得应用程序可以在不同的 Web 服务器上运行。WSGI 规范规定了
应用程序必须实现的接口方法和服务器需要支持的方法。WSGI 协议使得不同的 Python Web 框架（例如 Flask、
Django 等）能够在不同的 Web 服务器上运行，这些服务器可以是 Apache、Nginx 等。
uWSGI：uWSGI 是一个 Web 服务器，它是一个用 C 语言编写的 Web 应用程序容器，支持运行 Python、Ruby、
Perl 等多种编程语言。uWSGI 服务器可以作为一个独立的应用服务器，也可以与其他 Web 服务器（如 Nginx、
Apache）一起使用，通过 WSGI 协议与 Python 应用程序通信。
uwsgi：uwsgi 是一个与 uWSGI 服务器相关的协议。uwsgi 协议是一种二进制协议，它定义了 uWSGI 服务器与
应用程序之间的通信协议。使用 uwsgi 协议，uWSGI 服务器可以与 Python 应用程序通信，而不需要像 CGI 那
样启动一个新的进程来处理每个请求。uwsgi 协议允许 uWSGI 服务器与应用程序之间进行双向通信，从而提高了性能。
Nginx：Nginx是一个Web服务器其中的HTTP服务器功能和uWSGI功能很类似，但是Nginx还可以用作更多用途，
比如最常用的反向代理功能和缓存静态资源，加快访问速度。
用户——>web服务器——>web应用程序
浏览器—HTTP—>Nginx—uwsgi—>uWSGI—uwsgi—>web应用(Django等)
uwsgi是WSGI的一种实现

HTTP协议与TCP协议
TCP协议是传输层协议，主要解决数据如何在网络中传输
HTTP协议是应用层协议，主要解决如何包装数据
HTTP协议是建立在TCP协议基础之上的

OSI网络七层模型
物理层
定义：管理通信设备和网络媒体之间的互联互通。传输介质为数据链路层提供物理连接，实现比特流的透明传输。实现相邻计算机节点之间比特流的透明传送，屏蔽具体传输介质和物理设备的差异。
常用协议：物理线路，光纤，中继器，集线器，双绞线

数据链路层
定义：在计算机网络中由于各种干扰的存在，物理链路是不可靠的。该层的主要功能就是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。
它的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层的数据叫做帧。
常用协议：以太网，网卡，交换机，PPTP,L2TP，ARP，ATMP

网络层：计算机网络中如果有多台计算机，怎么找到要发的那台？如果中间有多个节点，怎么选择路径？这就是路由要做的事。
该层的主要任务就是：通过路由选择算法，为报文（该层的数据单位，由上一层数据打包而来）通过通信子网选择最适当的路径。这一层定义的是IP地址，通过IP地址寻址，所以产生了IP协议。
常用协议：IP，ICMP，RIP，IGMP,OSPF

传输层：当发送大量数据时，很可能会出现丢包的情况，另一台电脑要告诉是否完整接收到全部的包。如果缺了，就告诉丢了哪些包，然后再发一次，直至全部接收为止。
简单来说，传输层的主要功能就是：监控数据传输服务的质量，保证报文的正确传输。
常用协议：TCP,UDP

会话层：虽然已经可以实现给正确的计算机，发送正确的封装过后的信息了。但我们总不可能每次都要调用传输层协议去打包，然后再调用IP协议去找路由，所以我们要建立一个自动收发包，
自动寻址的功能。于是会话层出现了：它的作用就是建立和管理应用程序之间的通信。
常用协议：SSL，TLS，DAP,LDAP

表示层：表示层负责数据格式的转换，将应用处理的信息转换为适合网络传输的格式，或者将来自下一层的数据转换为上层能处理的格式。
常用协议：LPP，NBSSP

应用层：应用层是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。前端同学对应用层肯定是最熟悉的。
常用协议：HTTP，FTP，SMTP

socket和websocket？
协议不同
Socket 是基于传输层 TCP 协议的，而 Websocket 是基于 HTTP 协议的。Socket 通信是通过 Socket 套接字来实现的，而 Websocket 通信是通过 HTTP 的握手过程实现的。
持久化连接
传统的 Socket 通信是基于短连接的，通信完成后即断开连接。而 Websocket 将 HTTP 协议升级后，实现了长连接，即建立连接后可以持续通信，避免了客户端与服务端频繁连接和断开连接的过程。
双向通信
传统的 Socket 通信只支持单向通信，即客户端向服务端发送请求，服务端进行响应。而 Websocket 可以实现双向通信，即客户端和服务端都可以发起消息，实时通信效果更佳。
效率
Socket 通信具有高效性和实时性，因为传输数据时没有 HTTP 协议的头信息，而 Websocket 除了HTTP协议头之外，还需要发送额外的数据，因此通信效率相对较低。
应用场景
Socket 适用于实时传输数据，例如在线游戏、聊天室等需要快速交换数据的场景。而 Websocket 适用于需要长时间保持连接的场景，例如在线音视频、远程控制等。

